[{"id":"b48181ff5fc549c282670b2e3976c524","title":"PTA数据结构08","content":" 题目要求\n​\t\t因为一棵二叉树的遍历可以用堆栈来表示，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出\n Input Specification:\n6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\n Output Specification:\n3 4 2 6 5 1\n 解析：\n​\t\t首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为\ntypedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;\n​\t\t接下来考虑Push和Pop的对应操作该如何实现\nPush：对于一个结点优先访问其左子树，其次右子树\nPop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作\n 完整代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s\n","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","categories_index":"题目集","tags_index":"PTA,树","author_index":"shallow"},{"id":"1f2e6374a67016c059eddb723ab0efc5","title":"博客介绍","content":" 浏览介绍\n","slug":"博客介绍","date":"2021-11-26T05:38:30.000Z","categories_index":"教程","tags_index":"开发者,入站必读","author_index":"shallow"},{"id":"9fc91c89821b2cef82964b56dfea7164","title":"开发日志","content":" 2021.12.6\n本站开始期末冲刺计划，目标均分90-》😅幻想一下，其实是希望数理基础的几个科目能取得好成绩吧😅\n 2021.11.28\n本站技术博客暂停，因为开发者还不会在hexo中配置latex字体🥲\n 2021.11.26\n完善了个人资料卡的展示，添加了一个话痨小机器人，准备在有空的时候调教一番\n 2021.11.25\n开发者在寻求html+css+js来创建自己的网站时逐渐破防，遂选择了Hexo来搭建属于自己的网站，主题选择了非常wonderful的aurora\n","slug":"log","date":"2021-11-25T15:37:04.000Z","categories_index":"回忆","tags_index":"开发者","author_index":"shallow"},{"id":"447383d49ff18b4226a8582f8b4b6f53","title":"树(2)","content":" 二叉搜索树\n 定义：\n\n非空左子树所有键值小于根结点\n非空右子树所有键值大于根结点\n左右子树都是二叉搜索树\n\n 查找-Find\n\n查找某一给定键值元素：若比根结点大则去右子树找反之去左子树\n查找最大值/最小值：给定树的最右边或者最左边\n二叉搜索树的插入：即找到元素后插入\n\n 删除-Delete\n\n删除叶结点：直接删除，父结点指向NULL\n删除有一个子结点的结点：将其父结点的指针指向子结点\n删除有两个子结点的结点：从左子树中的最大值或者右子树的最小值找出一个来替代（转化为删除该结点）\n\n 平衡二叉树\n 定义：\n\n平衡因子：BF(T)=hL−hRBF(T)=h_L-h_RBF(T)=hL​−hR​，其中hL,h_L,hL​,hRh_RhR​分别左右子树的高度(层次)\n平衡二叉树(AVL树)：BF(T)≤1BF(T)\\leq1BF(T)≤1（包括空树）\n\n 性质\n\n给定结点为n的AVL树的最大高度为O(log2n)O(log_2n)O(log2​n)\n\n 平衡二叉树的调整\n\n概念：当插入一个新结点使得平衡二叉树不再平衡时，该结点称为破坏者，从该结点向上找父结点，则第一个被找到的不平衡的父结点称为发现者\nLL/RR插入：如果破坏者是发现者的左子树根结点的左子树上的点，则将发现者左子树的根结点（拎起来）作为新的根结点，其余结点按照二叉搜索树的规则有序排列（右子树根结点的右子树同理）\nLR?RL插入：如果破坏者是发现者的左子树根结点的右子树上的点，则将发现者，发现者的左子树的根结点，破坏者进行平衡，随后按照二叉搜索树的原则将断裂开的其余子树链接（右子树根结点的左子树同理）\n\n","slug":"树2","date":"2021-11-30T12:51:58.000Z","categories_index":"学习心得","tags_index":"浙大数据结构","author_index":"shallow"},{"id":"470c309602da5c2e94f04f070eda269c","title":"树(1)","content":" 树\n 查找\n数据管理的基本操作之一是查找：即根据某个给定的关键字K，从集合R中找出与K相同的记录\n\n静态查找：集合中的记录是固定的\n动态查找：集合中的记录是动态变化的，除查找外还可能发生插入和删除\n\n——如何实现有效率的查找？\n方法一：顺序查找\n遍历给定数组，找到目标元素或遍历完全部元素则结束遍历，此时时间复杂度为**O(n)O(n)O(n)**\n方法二：二分查找\n假设n个数据元素的关键字满足有序并且连续存放，可以进行二分查找\n即每次查找取一个左边界点和一个右边界点，取其中点进行判断，判断呆查找关键字与其大小关系，依此来更新查找范围,此时时间复杂度为**O(logn)O(log n)O(logn)**\n 二分查找判定树\n\n\n判定树上的每个结点需要的查找次数刚好为该结点所在的层数\n查找成功时查找次数不会超过判定树的深度\nn个结点的判定树的深度为**[log⁡n]+1[\\log n]+1[logn]+1**\n\n 树的定义\n\n树：n个结点构成的有限集合，树中有一个称为根的特殊结点，用root表示，其余结点可以分为不相交的有限集合，每个集合称为子树\n结点的度：结点的子树个树\n树的度：结点最大的度数\n叶结点：度为0的结点\n父结点：有子树的结点时期子树根结点的父结点\n子结点：与父结点对应\n兄弟结点：同一个父结点\n结点层次：规定根结点在第一层，其余结点依据其父结点层次加1\n树的深度：结点的最大层次\n树的表示：采用两个指针域，一个指向长子一个指向兄弟结点。倾斜此树形成二叉树\n\n 二叉树\n 定义：\n​\t\t\t可以为空的有穷结点的集合，由根结点和其左右子树组成\n 特殊二叉树：\n\n斜二叉树\n完美二叉树/满二叉树\n完全二叉树\n\n 重要性质：\n\n一个二叉树的第i层的最大结点数量是**2i−12^{i-1}2i−1**,i&gt;0\n深度为k的二叉树有的最大结点数量为**2k−12^k-12k−1**个,k&gt;0\n对任何非空二叉树而言若用n0n_0n0​来表示度为0的结点的个数，n2n_2n2​来表示度为2的结点的个数，有**n0=n2+1n_0=n_2+1n0​=n2​+1**成立\n\n 存储结构：\n\n\n顺序存储结构：\n适用于完全二叉树，结点为i的结点其父子树结点为[i2][\\frac{i}{2}][2i​],其左孩子的序号为2i，右孩子序号为2i+1\n\n\n链式存储结构：\n一般采用数据域加指向左右两孩子的指针域\n\n\n 二叉树的遍历：\n\n先序遍历\n中序遍历\n后序遍历\n\n 递归实现：\n​\t\t\t基本思路：将访问一棵树的过程抽象为：访问该树的根结点，若空则返回，若非空则依次访问其左右子树，所谓的遍历方式不同仅仅区别在何时打印出根结点\nvoid OrderTraversal(BinTree BT)&#123;\n  if(BT) &#123;\n    printf(&quot;%d&quot;,BT-&gt;Data);&#x2F;&#x2F;打印顺序不同则代表了不同的遍历方式\n    OrderTraversal(BT-&gt;left);\n    OrderTraversal(BT-&gt;right);\n\t&#125;\n&#125;\n 非递归实现\n​\t\t显然遍历树的方式不同但走过的路径相同，不妨将递归实现中的打印时机抽象为遍历树时对每个结点都访问三次。即初遇结点为第一次，遍历完结点左子树回来时为第二次，遍历完结点右子树回来时为第三次，在程序中我们将第一次访问抽象为push该结点到一个栈中，第二次访问抽象为将该结点从栈中pop出来\n\n先序遍历，在push时打印结点\n中序遍历，在pop时打印结点\n后序遍历，以根右左的形式进行先序遍历再倒序输出\n\nex：\nvoid PostorderTraversalStack(BinTree BT) &#123;\n    BinTree T&#x3D;BT;&#x2F;&#x2F;从根结点开始遍历\n    Stack S &#x3D; CreateStack(MAXSIZE); &#x2F;&#x2F;创建栈\n    while (!IsEmpty(S) || T) &#123;\t\t\t&#x2F;&#x2F;还有没被访问的元素（1，2次）\n        while (T) &#123;   \t\t\t\t\t\t\t&#x2F;&#x2F;一直向左并将沿途结点压入堆栈\n            Push(S, T);\n            T &#x3D; T-&gt;left;   &#x2F;&#x2F;右\n        &#125;\n        while (!IsEmpty(S)) &#123;\n            T &#x3D; pop(S);   &#x2F;*结点弹出堆栈，第二次访问*&#x2F;\n            T &#x3D; T-&gt;right;    &#x2F;&#x2F;左\n        &#125;\n    &#125;\n\n层序遍历：用一个队列保存遍历到的结点的子结点，按顺序访问队列中的结点即可\n\n","slug":"树1","date":"2021-11-30T02:18:26.000Z","categories_index":"学习心得","tags_index":"浙大数据结构","author_index":"shallow"},{"id":"116a0a10bb25c5d4c34813a7b24e608c","title":"飞盘新秀赛","content":" 飞盘新秀赛\n 开始\n因为这学期的必修体育课我选择了极限飞盘，所以作为课程成绩的一部分，我选择了参加第二届极限飞盘的新秀杯。说来遗憾，我在去年大一的时候也选择过极限飞盘的选修课但是当时没报，这次也算弥补了。\n 第一天\n抱着自我感觉良好的态度，在打第一场比赛之前我是抱着很轻松的态度去应对的，因为平时在课上我们也会组织这样的小比赛，而我的表现的都比较好所以自然觉得自己仍然会发挥的很好，但是第一场比赛彻底让我傻了眼\n我攻防的是一个白色衣服的男生，由于我之前根本就不知道怎么去突破对手的防守，也不知道怎么去接队长发的盘，导致我俩一直在场地的大后方横向跑动，没过多久我的体力就透支了。而这时在他向前冲刺去进攻时我便力不从心了，速度总是慢他一步，让他完成了很多关键的得分和传盘，也同时让我们的团队丢掉了原本在上半场取得的优势。而到了后来他们队伍换上了一个跑动更快的黑色衣服男生时，我根本就无法控制住那只黑色的兔子，最终我们也输掉了比赛，队长和我说不要局限于内耗，不要去横向跑动，如果向前冲之后没有接到盘就向后撤,我个人感觉这句话对我的帮助挺大的。\n第一天的第二局呢因为对手充分发挥女生多的优势，打的是一个32，所以当我上场时，比分已经很悬殊了，我从第一局中吸取到的经验教训也没有发挥太上用场。\n就这样，我第一天的比赛结束了，虽然是全败，但是我觉得这种拼抢，不断冲刺的感觉其实还挺棒的，于是我便放弃了水一水的想法，第二天依然要来拼一拼。\n 第二天\n第二天下午依然是开始的比较早，我就连忙赶去了，但是一去呢我绷不住了，因为我们算上队长呢只有5个人，这就挺有意思了，这意味着我们5个要一直坚持60分钟，这对于体力欠缺的我真是一个莫大的挑战。\n比赛开始后，让我开心的是我防的人速度不快，也不是很灵活，我便很得心应手，而且适当的冲到前面和另一个红色的衣服小哥去接队长的盘，并完成自我感觉不错的传盘，但是随着比赛的进行，对面不停的换人，而且我这个点每一分的时候防的人都不一样而且精力充沛，尤其是一个飞盘社的老手，直接把我搞的很难受，而且我们的女生在中场时由于体力不支无奈下场，我们只能以4个来面对对面的进攻，这种情势下，外加我的体力不支，我们逐渐落了下风，虽然后来赶过来几个同学，但那时剩余的时间已经不足以我们去做翻盘的事情，我们尽力的打好了最后一分，便接受了失败的事实\n第四场由于对手很菜我打的上半场5:0了对面，虽然下半场一度被追平，但我们把握住了最后一分的机会成功保住了倒数第二的头衔（乐）\n以上就是我关于我们比赛的一些流水账，下面我谈一谈个人的一些感受\n 个人感受\n\n\n关于飞盘精神：\n每场比赛结束后，两队队员拍成一列互相击掌，互相给对手点赞，之后大家围成一个大圈，谈谈自己的想法，谈谈对对手的感受，之后互相喊对方队伍的口号（好尴尬），在之后有一个精神文明的打分，就是依据大家的投票对对手的飞盘精神进行一个评价，这也是飞盘最高荣誉精神文明奖的评判标准，而之后我们的确成为了16支队伍中唯二的精神文明奖，不过那都是后话了\n\n\n关于我的收获\n我深刻的感受到了飞盘运动的魅力，大家都很友好，（除了有几个讨人厌的飞盘社的成员），整体的竞技水平很高但是氛围却很快乐，大家在我打的不好的时候不挖苦吐槽，而是鼓励并当面指出问题教我去怎么做，而在打得好的时候也从来不吝啬于他们的赞美，我们在低谷时一起走过，仍然努力拼搏每一分，我们在得分时雀跃欢呼，不吝啬对队友的赞美，这是年轻人最好的模样。\n对于我自身而言，这场比赛接触了几个对待比赛很认真的同学，在我们连输三场之后仍然守在赛场，拼搏到最后一秒，有时候我也会对自己产生的退缩念头而感到羞耻，希望自己以后能以更积极的态度去面对类似的挑战，去遇见更好的自己\n\n\n-----附上合影和精神文明奖品^ _ ^\n","slug":"飞盘新秀赛","date":"2021-11-28T11:17:04.000Z","categories_index":"回忆","tags_index":"运动,团队","author_index":"shallow"},{"id":"c64fb311e63f4c1eefb237f294f60a66","title":"PTA数据结构05","content":" 题目要求\n给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出&quot;YES&quot;,否则&quot;NO&quot;\n Input Specification:\n第一行依次为M、N、K，后跟K行样例\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n Output Specification:\nYES\nNO\nNO\nYES\nNO\n 解析\n由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止\n显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期\n 示例代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;\n","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","categories_index":"题目集","tags_index":"PTA,线性结构","author_index":"shallow"}]