[{"id":"e216c9ea1d09bf4491604c3c7ac9c5bf","title":"疫情日记","content":"2022年1月-从出不了宿舍开始的寒假生活1.1新年新气象，学校发了饭盒，今天一天没出宿舍，晚上睡觉熬到4点多学习：洛谷刷题枚举，模拟。疫情就是个几把，西安加油。（其实是1.2写的\n1.2出去买了早饭，西安新增有所减少，期望拐点的早日到来，另外听闻考试的消息，决定刷题和复习同时进行（真的好难啊，本来刷题就菜学习：洛谷找了份新题单，决定未来一段时间巩固基础算法，磨砺心智，今天做了第一部分模拟的大部分题，现在只能稳稳拿下普及-的题疫情就是个几把，今天体验了全新的核算排队方式，真是绝绝子，拥挤到跺jiojio，不说了，明天也是呆在宿舍混吃等死的一天\n1.3出去买午饭，今日无核算，中午饭还撒了，感觉最近吃饭营养不太均衡，牙龈不太舒服学习：上午做了会排序的题，下午晚上大部分时间耍手机了，这样不行，概率论做了第四章的题，总结总结感觉还行，明天主要推概率论，目标在考试通知下来前把各科知识穿一遍疫情就是个几把，奥力给！\n","slug":"diary","date":"2022-01-02T14:29:58.000Z","categories_index":"","tags_index":"开发者,日记","author_index":"shallow"},{"id":"6181be25ee551197b04a134e589faeae","title":"年度总结","content":"再见，2021收获走过了一年，虽然一路上坎坎坷坷，但还是有很多快乐和值得纪念的事情😙\n\n我转专业成功了\n从机类转到计算机相关专业，虽然转专业之后的部分课程并不是我想象中的那么美好，但我还是觉得幸运，感谢当时果断做决定的自己。\n\n\n我参加了十四运会志愿者队伍\n对于一个普通人而言，能够参加这样的盛会是件非常高兴的事情，对我而言也确实如此。\n我记得西铁院下午的阳光，食堂门口的喷泉因此有了五彩的颜色。\n我记得体育馆凌晨的月光，我们度过了近20天不眠的夜晚。\n我记得机动队的四个人，一个下午分发了3万份的物资。\n我记得司机师傅的疲惫的笑容，和作为安全员的我送了一批又一批的演员前往排练。\n我当然还记得那时的火炬，仿佛要驱散一切阴霾似得，燃的热烈。正像大雨中的我们，虽然疲惫不堪却笑容满面，这种充满无私奉献，乐观主义的奋斗精神很难不让人热泪盈眶。\n\n\n我选择了很棒的技术社团和菁英班\n在RM的日子让我受益匪浅，我认识了很多优秀的学长和同龄人，和他们共同努力真的是件很棒的事，虽然自己在新知识的学习上愚笨而且懈怠，但也算是有所收获，希望2022年RM校队打破队史，再创佳绩！\n通过百度大数据人工智能菁英班的选拔是在我意料之外的事情，希望自己能对得起着来自不易的机会，在未来一周年的培养计划中向大佬们学习，不愧对这份幸运。\n\n\n\n遗憾又是一年风雨兼程，今年的我又有怎样的感叹呢🥲\n\n我还需要更成熟\n都说性格决定命运，以前我是不信的，现在倒有点相信了。由于我的没心没肺，错过了很多可能改编我人生轨迹的事情，在与人交往的过程中也有很多不当之处，希望未来的自己能够严于律己，凡事三思而后行。\n\n\n我还需要更勇敢\n还记得去年这个时候我在华山许愿，希望自己的2021年变得勇敢，能够万事胜意，。我也确实做到了一部分，可我还是觉得远远不够，对于一些毫无把握的事我也许可以再尝试尝试，万一就出现转机了呢，对于现在一无所有的我而言，如果再不够勇敢那就真的什么都不剩下了，希望未来一年不要错过一切我在意的东西。\n\n\n我还需要更自律\n过度沉迷手机，刷一些无意义的内容占用了我大量的休息时间，它们原本可以有更好的安排，但我没有这样做，也许这种事后诸葛亮的呻吟可能一点用处都没有，但我还是希望自己可以更加自律，合理安排自己的生活。\n\n\n\n你好，2022期望\n学业成绩和竞赛不留遗憾，戒骄戒躁，珍惜大学本科时光。\n生活不留遗憾，依然要投身志愿活动中，那是我一直坚持的。\n对自己不留遗憾，对于在意的事情要努力去争取。\n\n\n那么新年第一条愿望，就是祝看到这个博客的你2022得偿所愿，日日顺心🥰","slug":"my2021","date":"2021-12-31T13:12:12.000Z","categories_index":"总结","tags_index":"开发者","author_index":"shallow"},{"id":"b48181ff5fc549c282670b2e3976c524","title":"PTA数据结构08","content":"题目要求​        因为一棵二叉树的遍历可以用堆栈来模拟，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出\nInput Specification:6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\nOutput Specification:3 4 2 6 5 1\n解析：​        首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为\ntypedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;\n​        接下来考虑Push和Pop的对应操作该如何实现\nPush：对于一个结点优先访问其左子树，其次右子树\nPop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作\n完整代码#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s\n","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","categories_index":"题目集","tags_index":"PTA,树","author_index":"shallow"},{"id":"c64fb311e63f4c1eefb237f294f60a66","title":"PTA数据结构05","content":"题目要求给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出”YES”,否则”NO”\nInput Specification:第一行依次为M、N、K，后跟K行样例\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\nOutput Specification:YES\nNO\nNO\nYES\nNO\n解析由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止\n显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期\n示例代码#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;\n","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","categories_index":"题目集","tags_index":"PTA,线性结构","author_index":"shallow"},{"id":"1f2e6374a67016c059eddb723ab0efc5","title":"博客介绍","content":"这是一个怎样的博客？博客性质\n个人博客，分享生活感悟\n记录博客，分享学习心得\n\n你能在这里收获什么\n了解开发者的心路历程，与开发者共情（反正就是好朋友 😠）\n学习上获得帮助：本站主要是技术内容的分享\n\n如何使用本站？\n通过tag或category标签来检索内容\n合理设置关键字，在搜索框中进行检索\n\n还没想好\n未完待续\n未完待续\n未完待续\n\n","slug":"博客介绍","date":"2021-11-26T05:38:30.000Z","categories_index":"教程","tags_index":"开发者,入站必读","author_index":"shallow"}]