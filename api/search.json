[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":" codeforces#823-div2-B\n题意：一维坐标系有n个人，各自的坐标为xix_ixi​，每个人需要ti的时间才能出发，问需要多长时间才能让所有人聚集到一个地方\n解答：若每个人所需要的时间tit_iti​都是0的话，则答案为xmax+xmin2\\frac{x_{max}+x_{min}}{2}2xmax​+xmin​​,若用二元组(xi,ti)(x_i, t_i)(xi​,ti​)来表示每个人的状态的话(xi,ti)(x_i, t_i)(xi​,ti​)可以转化为(xi+ti,0)(x_i + t_i, 0)(xi​+ti​,0)和(xi−ti,0)(x_i - t_i, 0)(xi​−ti​,0)\n codeforces#COMPFEST 14-G\n题意：对于一个三角形而言，求其中一条直角边的所有平方取值中第n小的一个\n解答：设一条边为aaa，另一条边为a+1a+1a+1，所求值可以表示为2a+12a+12a+1, 设一条边为aaa另一条边为a+2a+2a+2，所求值可以表示为4a+44a+44a+4，这两个数一个是大于等于3的所有奇数，一个是大于等于8的所有4的倍数，观察其补集，对于模4得2的集合而言，由于任何平方数对4取模都只能得到0或1，\n","slug":"思维","date":"2022-10-05T13:59:32.131Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"8a05039005e8271de59259f4550f4e1d","title":"思维","content":" codeforces#823-div2-B\n题意：一维坐标系有n个人，各自的坐标为xix_ixi​，每个人需要ti的时间才能出发，问需要多长时间才能让所有人聚集到一个地方\n解答：若每个人所需要的时间tit_iti​都是0的话，则答案为xmax+xmin2\\frac{x_{max}+x_{min}}{2}2xmax​+xmin​​,若用二元组(xi,ti)(x_i, t_i)(xi​,ti​)来表示每个人的状态的话(xi,ti)(x_i, t_i)(xi​,ti​)可以转化为(xi+ti,0)(x_i + t_i, 0)(xi​+ti​,0)和(xi−ti,0)(x_i - t_i, 0)(xi​−ti​,0)\n codeforces#COMPFEST 14-G\n题意：对于一个三角形而言，求其中一条直角边的所有平方取值中第n小的一个\n解答：设一条边为aaa，另一条边为a+1a+1a+1，所求值可以表示为2a+12a+12a+1, 设一条边为aaa另一条边为a+2a+2a+2，所求值可以表示为4a+44a+44a+4，这两个数一个是大于等于3的所有奇数，一个是大于等于8的所有4的倍数，观察其补集，对于模4得2的集合而言，由于任何平方数对4取模都只能得到0或1，所以(b2%4−a2%4+4)%4(b^2\\%4-a^2\\%4 + 4)\\%4(b2%4−a2%4+4)%4只会取到0，1，3所以该等价集被舍弃，通过暴力验证发现1和4得不到，接下来通过推公式或者二分即可得到答案\n codeforces#817-div4-G\n题意：构造一个长度为n，数字各不相同的数组，每个元素的最大值不可以超过10910^9109让这个数组异或和为0\n解答：考虑由偶数开始的连续四个数字，他们的异或和为0，将n中是4的倍数的部分单独列出（从4开始枚举，123另用）如果n%4==1n\\%4==1n%4==1就添加0，如果n%4==2n\\%4 == 2n%4==2就先将序列任意一个数改成一个足够大的数，保证2进制状态下n个数的最高位都没有它高，\n取此时序列的异或和，添加此异或和即可，如果n%4==3n\\%4==3n%4==3添加123即可\n","slug":"思维1500-1700","date":"2022-10-05T08:09:56.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":" 二分答案\n前提：满足答案单调性，当求解一个问题过程需要考虑的因素比较复杂，很难通过已知要素直接推断出结果，而且因素之间互相影响， 则考虑二分答案，或者更明显的求最小值的最大值，最大值的最小值\n 格式\n不断缩减解空间的大小，整数缩减到1，浮点数缩减到精度eps\nint l, r;\nwhile (r - l &gt; 1)&#123;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    if (check(mid)) l &#x3D; mid;\n    else r &#x3D; mid;\n&#125;\ncout &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n&#x2F;&#x2F;显然此处的解空间是[l, r)\n\ndouble l, r;\nwhile (r - l &gt; eps)&#123;\n    double mid &#x3D; (l + r) &#x2F; 2;\n    if (check(mid)) l &#x3D; mid;\n    else r &#x3D; mid;\n&#125;\ncout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; l &lt;&lt; &#39;\\n&#39;;\n&#x2F;&#x2F;显然此处eps精度为1e-6\nps:需要注意的点是，尽量把端点确定的精准一点有些题卡的比较死\n 函数\nlower_bound() 与 upper_bound()，对于一个区间的两个端点，如果想在一个有序序列中划出，左端点采用大于等于，右端点采用大于，这样得出的答案一定是[l, r)\n 二分+贪心+前缀和\n 跳石头：一条河，一些石头，现在希望去掉一些石头使得跳跃最小距离最大，首先跳跃的最小的距离必须大于等于河的长度，其次对于check函数，累计自身还没跳的距离，一旦大于设定的最短距离就跳，累计的距离清空，否则就把石头拿掉继续累积没跳的距离\n 牛子排队：一群牛牛站成一排，每个牛牛在达到第一名之后插到队尾固定的位置，如果排队次数不限，问有多少个牛牛不能排到第一位，首先分析如果一个牛牛不能排到第一位则他之后的牛牛都不能排到第一，则答案满足单调性，接着考虑某个牛牛如果能到达第一位的充要条件是他前面的所有牛牛都能到他后面，由于在第一只牛牛到达他后面之前，他后面牛牛的数量是一定的，而且一次最多增加一只牛牛，将他前面的牛牛排序，最容易查到他后面的牛牛先插，插完空间加1，如果这样都不能插那肯定不行，因为比你大的更插不进去\n 扑克牌：有若干种普通扑克牌各若干张，赖子牌若干张，已知赖子牌可以替换任意普通牌， 所有扑克牌各一张可以组成一套牌，一套牌中最多只能有一张赖子牌：首先先确定check函数，能否凑成x套牌？可以转化为需要多少赖子牌才可以组成x套牌，最后赖子牌的数量应该小于等于min(x, m)(m是赖子牌原有的数量)对于每一种牌，如果数量不够x张就用赖子牌补齐，这里要注意的是，不需要你确定具体牌是怎么分配的，你只需要知道只要赖子牌总数不超过x张，每种牌都有x张（算上赖子牌）就一定可以完成目标\n 第k大的数：给定一个序列A，对于其所有长度大于k的子区间，把其中的第k大的数加入一个空序列，求这空序列第m大的数：枚举这个数，通过双指针寻找包含至少k个大于等于二分值的区间数量，判断是否大于等于m个即可\n 分蛋糕：一个蛋糕要切成A*B份，必须横向A-1刀，纵向B-1行， 求一种切法使得最小的蛋糕最大，两个坐标确定一个矩形，所以优先设定左上角的值，右下角的值直到切出来的值大于二分值再切，而且如果发现纵向不够B个则放弃本次切，否则更改左上角的坐标位置\n 二分递归解决问题\n 位数差：给定一个数组，对于任意两个数字，其位数差定义为右边的数字加上左边的数字得到的数字位数比左面的数字大几位，求这个数组位数差之和：一个数组的位数差之和等于左区间的答案加上右区间的答案外加左区间的每个数对于右区间每个数所产生的位数差的贡献，事先设定一个数组存有10的幂级，在递归时，将右区间排序，对于10的每个幂级，在右区间直接二分查找，而由于单次产生的差值恰好与两个数之间包含了几个10的幂级相同，所以结果不会出错\n 三分答案\n对于一个单峰函数而言，三分答案可以不断逼近最终的值，而往往三分的题可以在考虑时间复杂度的情况下直接暴力细分区间来做\n 传送带：有两条线段以及一个平面，有一个物块想从其中一条线段的端点移动到另一条线段的端点，其中三条线段的移动速度各不相同，求所花时间的最小值，如果固定第一条线段的值，发现对于另一条线段上的点是一个单峰函数，可以用三分解决，同时固定第一条线段值这个过程也是一个三分的过程，所以是三分套三分，另外还有一种解法，即细分两条线段区间，依次枚举，求最小值即可，具体细分程度要考虑浮点数精度和时间复杂度\n 期末考试：有若干门课程发布时间，有若干同学，每个人都有期望的所有课程发布的时间，该时间晚一天就会产生一定的不愉快度，同时还有两种调整课程发布时间的方法，一种是直接提前某门课的时间B，另一种是延后某一门而提前另一门A，这两种方法各自拥有不同的愉快度，求总体产生的最小愉快度：方法是暴力：强行通过枚举的方式来使某一种参数确定下来而分析另外的因素，所以直接枚举课程发布的最晚时间，总不愉快度由两部分确定，一种是学生的不愉快度，另一种如果B小于等于A的话肯定全用B， 否则优先用A， 但是要考虑A最多能用多少\n","slug":"二分","date":"2022-09-28T02:43:27.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"81579b6c641dedc829a2b0058112fc0c","title":"数据结构","content":" 1.RMQ-st表\n离线查询区间最值\ntemplate&lt;class T, class Cmp &#x3D; less&lt;T&gt;&gt; &#x2F;&#x2F;定义模版：数据类型和比较方式，默认广义小于\nstruct RMQ&#123;\n    const int n;&#x2F;&#x2F;数组长度[0, n)\n    const Cmp cmp;&#x2F;&#x2F;比较方式\n    vector&lt;vector&lt;T&gt;&gt; a;&#x2F;&#x2F;st表\n    RMQ(const vector&lt;T&gt;&amp; init) : n(init.size()), cmp(Cmp())&#123;\n        int lg &#x3D; log2(n);\n        a.assign(n, vector&lt;T&gt;(lg + 1));&#x2F;&#x2F;用n个vector&lt;T&gt;(lg + 1)填充a\n        for (int j &#x3D; 0; j &lt;&#x3D; lg; ++j)&#123;\n            for (int i &#x3D; 0; i + (1 &lt;&lt; j) &lt;&#x3D; n; ++i)&#123;\n                a[i][j] &#x3D; (j &#x3D;&#x3D; 0 ? init[i] : min(a[i][j - 1], a[i + (1 &lt;&lt; (j - 1))][j - 1], cmp));\n            &#125;\n        &#125;\n    &#125;\n    T range(int l, int r)&#123;&#x2F;&#x2F;查询[l, r]\n        int k &#x3D; log2(r - l + 1);\n        return min(a[l][k], a[r - (1 &lt;&lt; k) + 1][k], cmp);\n    &#125;\n&#125;;\nRMQ&lt;int, greater&lt;&gt;&gt; rmq1;&#x2F;&#x2F;最大值\nRMQ&lt;int, less&lt;&gt;&gt; rmq2;&#x2F;&#x2F;最小值\n 2.线段树-(单点修改，区间最大值查询)(不带lazy tag)\nvoid add(int p, int l, int r, int pos, int x)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        ans[p] &#x3D; (ans[p] + a + x) % mod;&#x2F;&#x2F;替换为修改\n        return;\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    if (pos &lt;&#x3D; mid) add(p &lt;&lt; 1, l, mid, pos, x);\n    else add(p &lt;&lt; 1 | 1, mid + 1, r, pos, x);\n    ans[p] &#x3D; max(ans[p &lt;&lt; 1], ans[p &lt;&lt; 1 | 1]);\n&#125;\nint query(int p, int l, int r, int nl, int nr)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        return ans[p];\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1, res &#x3D; 0;\n    if (nl &lt;&#x3D; mid) res &#x3D; max(res, query(p &lt;&lt; 1, l, mid, nl, nr));\n    if (nr &gt; mid) res &#x3D; max(res, query(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr));\n    return res;\n&#125;\n 3.线段树-(区间加，区间和查询)（带lazy tag）\n对于区间加和区间乘同时存在的问题，一定要先区间乘后区间加，同时在lazy tag方面要注意加法的tag要小心\nvoid build(int p, int l, int r)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        ans[p] &#x3D; a[l];\n        return;\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    build(p &lt;&lt; 1, l, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, r);\n    ans[p] &#x3D; ans[p &lt;&lt; 1] + ans[p &lt;&lt; 1 | 1];\n&#125;&#x2F;&#x2F;递归建树，p管理的节点为自己的时候直接赋值\nvoid push_down(int p, int l, int r)&#123;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    ans[p &lt;&lt; 1] +&#x3D; (mid - l + 1) * lazy[p];\n    ans[p &lt;&lt; 1 | 1] +&#x3D; (r - mid) * lazy[p];\n    lazy[p &lt;&lt; 1] +&#x3D; lazy[p];\n    lazy[p &lt;&lt; 1 | 1] +&#x3D; lazy[p];\n    lazy[p] &#x3D; 0;\n&#125;&#x2F;&#x2F;向下传递，在更新或者查询时当前节点不完全被覆盖则向下传递lazytag\nvoid add(int p, int l, int r, int nl, int nr, int x)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        ans[p] +&#x3D; (r - l + 1) * x;\n        lazy[p] +&#x3D; x;\n        return;\n    &#125;\n    push_down(p, l, r);\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    if (nl &lt;&#x3D; mid) add(p &lt;&lt; 1, l, mid, nl, nr, x);\n    if (nr &gt; mid) add(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr, x);\n    ans[p] &#x3D; ans[p &lt;&lt; 1] + ans[p &lt;&lt; 1 | 1];\n&#125;\nll query(int p, int l, int r, int nl, int nr)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        return ans[p];\n    &#125;\n    push_down(p, l, r);\n    int res &#x3D; 0, mid &#x3D; (l + r) &gt;&gt; 1;\n    if (nl &lt;&#x3D; mid) res +&#x3D; query(p &lt;&lt; 1, l, mid, nl, nr);\n    if (nr &gt; mid) res +&#x3D; query(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr);\n    return res;\n&#125;\n 4. 树状数组护差分数组，支持单点查询，区间修改\nconst int maxn;&#x2F;&#x2F;数组长度扩2倍\nstruct BIT&#123;\n    int c[maxn];\n    void add(int x, int k)&#123;\n        while (x &lt;&#x3D; maxn)&#123;\n            c[x] +&#x3D; k;\n            x +&#x3D; x &amp; -x;\n        &#125;\n    &#125;\n    int query(int x)&#123;\n        int res &#x3D; 0;\n        while (x)&#123;\n            res +&#x3D; c[x];\n            x -&#x3D; x &amp; -x;\n        &#125;\n        return res;\n    &#125;\n&#125;tree;\n例题：你可以进行以下3种操作\n\n增加一个区间\n删除一个区间\n查询有多少个区间包含x+k*t 其中x值给定，k是固定值在操作之前给出\n\n首先考虑k=0的情况，用树状数组维护差分数组单点查询即可，先做一次离散化再操作\n当k不为0时，考虑将L，R， X对k取模，结果由[0, k - 1] 映射到[1, k]上，取模之前，如果区间长度大于k直接在[1,k] 上都加1\n反之，考虑l &gt;r时，对[l, k] 和[1, r] 进行操作\n","slug":"数据结构","date":"2022-07-27T10:16:02.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"d176c206991d53e1e298250d745ffd4f","title":"math","content":"\n\n质数分解定理：$$x = {p_1}{k_1}*{p_2}{k_2}{p_3}{k_3}*{p_4}{k_4}···{p_n}^{k_n}$$\n&#x2F;&#x2F;试除法\nint x;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; x; ++i)&#123;\n    if (x % i &#x3D;&#x3D; 0)&#123;\n        cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (x !&#x3D; 1) cout &lt;&lt; x ;\n\n\n快速幂\nlong long qpow(long long a, long long b, long long mod)&#123;\n    long long res &#x3D; 1;\n    while (b)&#123;\n        if (b &amp; 1) res &#x3D; res * a % mod;\n        a &#x3D; a * a % mod;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\n\n线性筛\n特点：每个合数都被且仅被其最小质因子筛一次\nbool isprime[maxn];&#x2F;&#x2F;对空间有要求\nvector&lt;int&gt; pos;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; maxn; ++i)&#123; &#x2F;&#x2F; 如果要筛出所有的质数这里的i的限制条件应该改一下\n    if (!isprime[i])&#123;\n        pos.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; pos.size() &amp;&amp; pos[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        isprime[i * pos[j]] &#x3D; 1;\n        if (i % pos[j] &#x3D;&#x3D; 0)&#123;\n            break;\n        &#125;\n    &#125;\n&#125;\n\n\n矩阵快速幂，矩阵加速递推\nstruct node&#123;\n    int a[n][n];\n    node()&#123;memset(a, 0, sizeof(a))&#125;&#x2F;&#x2F;初始化\n    node operator * (node b)&#123;\n        node x;\n        for (int i &#x3D; 0; i &lt; n; ++i)&#123;\n           for (int j &#x3D; 0; j &lt; n; ++j)&#123;\n               x[i][j] &#x3D; 0;\n               for (int k &#x3D; 0; k &lt; n; ++k)&#123;\n                   x[i][j] &#x3D; (x[i][j] + a[i][k] % MOD * b[k][j] % MOD) % MOD;\n               &#125;\n           &#125;\n        &#125;\n        return x;\n    &#125;\n&#125;;\nnode qpow(node a, long long b, long long mod)&#123;\n    if (b &#x3D;&#x3D; 1) return a;\n    node x;b--;\n    &#x2F;&#x2F;这里的处理可以直接新建一个单位矩阵，注意初始化对角线为1\n    while(b)&#123;\n        if (b &amp; 1)&#123;\n            x &#x3D; x * a;\n        &#125;\n        a &#x3D; a * a;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return x;\n&#125;\n\n\n中国剩余定理（CRT，模数互质）\nvector&lt;ll&gt; mod(k + 1), yu(k + 1);\nll ans &#x3D; 0, M &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n    M *&#x3D; mod[i];\n&#125;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    ll mi &#x3D; M &#x2F; mod[i], t, y;\n    euclid(mi, mod[i], t, y);\n    t &#x3D; t % mod[i];\n    ans &#x3D; (ans + yu[i] * mi * t) % M;\n&#125;\ncout &lt;&lt; (ans + M) % M &lt;&lt; &#39;\\n&#39;;\n\n\n扩展中国剩余定理（EXCRT，模数不互质）\nvector&lt;ll&gt; mod(k + 1), yu(k + 1);\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n&#125;\nll ans &#x3D; yu[1], mi &#x3D; mod[1], t &#x3D; 0, y &#x3D; 0;\nfor (int i &#x3D; 2; i &lt;&#x3D; k; ++i)&#123;\n    ll res &#x3D; ((yu[i] - ans) % mod[i] + mod[i]) % mod[i];\n    ll gcd &#x3D; euclid(mi, mod[i], t, y);\n    if (res % gcd !&#x3D; 0)&#123;cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;return 0;&#125;\n    t &#x3D; qmul(t, res &#x2F; gcd, mod[i]);\n    ans +&#x3D; t * mi;\n    mi &#x3D; mi &#x2F; gcd * mod[i];\n    ans &#x3D; (ans % mi + mi) % mi;\n&#125;\ncout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n\n\n欧拉函数：小于等于n，与n互质的数的个数\n对于n=p1k1∗p2k2∗p3k3⋅⋅⋅pnknn = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}···{p_n}^{k_n}n=p1​k1​∗p2​k2​∗p3​k3​⋅⋅⋅pn​kn​,φ(n)=n∏i=1npi−1pi\\varphi (n)=n\\prod_{i=1}^{n}\\frac{p_i-1}{p_i}φ(n)=n∏i=1n​pi​pi​−1​\n&#x2F;&#x2F;试除求单个n的欧拉函数\nint n;\nint res &#x3D; n;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; n; ++i)&#123;\n    if (n % i &#x3D;&#x3D; 0)&#123;\n        res &#x3D; res &#x2F; i * (i - 1);\n        while (n % i &#x3D;&#x3D; 0) n &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (n &gt; 1) res &#x3D; res &#x2F; n * (n - 1);\n\n&#x2F;&#x2F;筛法求1～n的欧拉函数值\nbool vis[maxn];\nvector&lt;int&gt; prime;\nint d[maxn];\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        d[i] &#x3D; i - 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; n; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (prime[j] % i &#x3D;&#x3D; 0)&#123;\n            d[m] &#x3D; d[i] * prime[j];\n            break;\n        &#125;\n        else&#123;\n            d[m] &#x3D; d[i] * (prime[j] - 1);\n        &#125;\n    &#125;\n&#125;\n\n\n\n线性筛求1～n每个数的约数个数,约数和\nn=p1k1∗p2k2∗p3k3⋅⋅⋅pnknn = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}···{p_n}^{k_n}n=p1​k1​∗p2​k2​∗p3​k3​⋅⋅⋅pn​kn​\n约数个数=(k1+1)(k2+1)(k3+1)⋅⋅⋅(kn+1)(k_1+1)(k_2+1)(k_3+1)···(k_n+1)(k1​+1)(k2​+1)(k3​+1)⋅⋅⋅(kn​+1)\n约数和=(1+p1+p12+⋅⋅⋅p1k1)⋅⋅⋅(1+pn+pn2+⋅⋅⋅pnkn)(1+p_1+p_1^2+···p_1^{k_1})···(1+p_n+p_n^2+···p_n^{k_n})(1+p1​+p12​+⋅⋅⋅p1k1​​)⋅⋅⋅(1+pn​+pn2​+⋅⋅⋅pnkn​​)\n\n\n&#x2F;&#x2F;约数个数根据乘法原理，维护最小的质因子个数\nbool vis[maxn];\nvector&lt;int&gt; p;\nint d[maxn];&#x2F;&#x2F;储存约数个数\nint a[maxn];&#x2F;&#x2F;最小质因子个数\n\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; 1;\n        d[i] &#x3D; 2;\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[m] * (a[m] + 1);\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1;\n            d[m] &#x3D; d[i] * 2;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;同约数个数，从最小质因子的约数和入手\nint d[maxn];&#x2F;&#x2F;约数和\nint a[maxn];&#x2F;&#x2F;最小质因子约数和\na[1] &#x3D; d[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; d[i] &#x3D; i + 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m&#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; prime[j] * a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[i] * a[m];\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1 + prime[j];\n            d[m] &#x3D; a[m] * d[i];\n        &#125;\n    &#125;\n&#125;\n\n\n扩展欧几里得算法\nll exgcd(ll a, ll b, ll x, ll y)&#123;\n    return !b ? (x &#x3D; 1, y &#x3D; 0, a) : (exgcd(b, a % b, y, x), y -&#x3D; (a &#x2F; b) * x);\n&#125;\n\n\n威尔逊定理及其扩展\nppp是质数的充分必要条件是(p−1)!≡−1(mod p)(p-1)!\\equiv -1(mod \\ p)(p−1)!≡−1(mod p)\n推论：\n\n\n(p−1)!+1≡0(mod p)(p-1)!+1\\equiv0(mod \\ p)(p−1)!+1≡0(mod p)质数的充要条件\n\n\n(p−1)!≡0(mod p)(p-1)!\\equiv0(mod \\ p)(p−1)!≡0(mod p)非质数的充要条件\n\n\n\n\n组合数（取模）\n&#x2F;&#x2F;阶乘预处理，线性求逆元\nll fac[maxn + 1], inv[maxn + 1], mod;\nfac[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; maxn; ++i) fac[i] &#x3D; fac[i - 1] * i % mod;\ninv[maxn] &#x3D; qpow(fac[maxn], mod - 2);\nfor (int i &#x3D; maxn - 1; i &gt;&#x3D; 0; --i) inv[i] &#x3D; inv[i + 1] * (i + 1) % mod;\n\n\n","slug":"math","date":"2022-07-22T13:11:52.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"1840725987698b4cef5a9ce40df0584c","title":"队列","content":" 栈\n 出栈排序\n给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序\n对当前元素入队，如果栈顶元素大于之后的所有元素，出栈\n 队列\n 插队\n给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进队后出队\n解答：设计一个队列，如果一个人没有插队一定是当他出队时正好在队伍的开头，即前面的所有人都已经出队。出队时，如果正好这个人在队头，出队，否则，标记这个人已经离开队伍，且插队的人数加一，在每次判断队头的人是不是已经出队之前先用while循环删除已经出队的人\n 前后调\n对于一个给定的序列，有两种操作，一个是将某元素移到队头，一个是将某元素移到队尾，问若干次移动后队列长啥样\n对每个元素x而言，设立数组p[x]=i,另设队头，队尾指针l=1，r=n每次移动元素时直接p[x]=l–或p[x]=r++;最后直接用p[x]的大小排序\n 单调队列\n建立一个队列，队列中元素单调且满足其中的最大值是当前覆盖区间的最大值，最小值是尾元素，换言之，一个元素只有在有更大的元素入队时才会被删除\n 模版\n\n判断队头元素是否需要出队\n使用队头的最值\n判断队尾元素是否需要出队\n队尾插入新元素的下标\n\n 滑动窗口\nint k;&#x2F;&#x2F;滑动窗口维护最大值，k为窗口长度\nvector&lt;int&gt;a(n+1);&#x2F;&#x2F;元素容器\ndeque&lt;pair&lt;int,int&gt;&gt;q;&#x2F;&#x2F;&#123;序号，值&#125;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(!q.empty()&amp;&amp;q.back().second&lt;a[i].second)&#123;\n        q.pop_back();\n    &#125;\n    q.push_back(&#123;i,a[i]&#125;);\n    if(q.front().first&#x3D;&#x3D;k+x-1)&#123;\n        q.pop_front();\n    &#125;\n    if(i&gt;&#x3D;k)&#123;\n        cout&lt;&lt;q.front()&lt;&lt;&#39;\\n&#39;;\n    &#125;\n&#125;\n 连续子序列最大和:给出一个序列，求出子序列长度不超过m的最大子序列和\n先用前缀数组预处理给定的序列，将sum[0]=0同样算入，对于 i&gt;=m，考虑kϵ[i−m,i−1]k \\epsilon [i-m,i-1]kϵ[i−m,i−1]这个区间，通过sum[i]−sum[k]sum[i]-sum[k]sum[i]−sum[k]则实现了寻找右边界为i长度不超过m的子序列最大和（只需要找到sum[k]的最小值即可），对于区间移动则可以用单调队列来解决\nint m;&#x2F;&#x2F;序列最大长度\nvector&lt;int&gt;sum(n+1);&#x2F;&#x2F;预处理前缀和数组\ndeque&lt;pair&lt;int,int&gt; &gt;q;\nq.push(&#123;sum[0],0&#125;);\nint ans&#x3D;-0x7fffffff;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(q.size()&amp;&amp;q.back().first&gt;sum[i])q.pop_back();\n    if(i&gt;&#x3D;m)&#123;\n        ans&#x3D;max(ans,sum[i]-sum[q.front().second]);\n    &#125;\n    q.push_back(&#123;sum[i],i&#125;);\n    if(q.front().second&#x3D;&#x3D;i-m+1)q.pop_front();\n    cout&lt;&lt;ans&lt;&lt;&#39;\\n&#39;;\n&#125;\n 单调栈\n寻找某一个元素作为最大值或最小值，向左或向右扩展的区间\nex:\nstack&lt;pair&lt;int,int&gt; &gt;s;&#x2F;&#x2F;(a[i],i)\nvector&lt;int&gt;r(n+1);&#x2F;&#x2F;作为最大值扩展区间的右边界\nfor(int i&#x3D;n;i&gt;&#x3D;1;--i)&#123;\n    while(!s.empty()&amp;&amp;s.top().first&lt;a[i])s.pop();\n    if(s.empty())r[i]&#x3D;n;\n    else r[i]&#x3D;s.top().second-1;\n    s.push(&#123;a[i],i&#125;);\n&#125;\n 区区区间间间\n定义价值为一个区间最大值-最小值\n求所有长度大于2区间的价值总和\n跑两遍单调栈，对于每个元素，其作为端点管理的区间加上其作为区间内管理的区间，值得注意的是跑两遍中，应有一遍不加等号一遍加，这样在出现相同元素相邻时一个元素只作为端点管理一边，而一个元素会管理另一边，杜绝了区间重复发生\n","slug":"队列","date":"2022-06-22T04:50:06.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"cf16dcad745c39bc496f066c73c8929e","title":"特殊的数据结构","content":" 维护序列中最小未出现过的非负整数，支持插入，查询，删除\n用一个数组记录每个数出现过的次数，用set维护一个按大小排列的未出现过数\nint cot[maxnum];\nset&lt;int&gt;st;\nint m;\nint op, x;\nvoid solve() &#123;\n\tfor (int i &#x3D; 0; i &lt; maxnum; i++)st.insert(i);\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tcin &gt;&gt; op;\n\t\tif (op &#x3D;&#x3D; 0) &#123;\n\t\t\tcin &gt;&gt; x;\n\t\t\tif (cot[x] &#x3D;&#x3D; 0) &#123;\n\t\t\t\tst.erase(x);\n\t\t\t&#125;\n\t\t\tcot[x]++;\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; 1) &#123;\n\t\t\tcout &lt;&lt; *st.begin() &lt;&lt; endl;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcin &gt;&gt; x;\n\t\t\tif (cot[x] &#x3D;&#x3D; 1) &#123;\n\t\t\t\tst.insert(x);\n\t\t\t&#125;\n\t\t\tcot[x]--;\n\t\t&#125;\n\t&#125;\n\n&#125;\n","slug":"特殊的数据结构","date":"2022-05-21T14:49:59.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"ec879031a4be3590103f0fd58b750e46","title":"cf-792-div1+2","content":" C\n题意：给定一个矩阵，你可以将任意两列交换至多一次，问能否使矩阵每一行不下降\n方法：读入矩阵，对每一行重新排序，若与原序列不同则加入有问题数组，数组长度大于2则不可能交换一次解决，否则将矩阵交换该两列，看是否满足答案\n题意：给定一个2行n列的矩阵，可以任意交换两列，问能否使矩阵的每一行都不下降\n D\n题意：给定n个陷阱，你需要按顺序走过这些陷阱，每个陷阱会对你造成固定伤害，你可以跳过k个陷阱，但是每跳过一个陷阱后续所有的陷阱造成的伤害都会加一，求走完n个陷阱所受到的最小伤害\n方法：\n首先贪心的考虑一定要用完所有跳过的机会，如果不想让后面的陷阱变大跳过最后一个便是了，其次考虑跳过每个陷阱所减少的伤害数：\n若跳过第i个陷阱，则减少伤害a[i]但其后面会增加n−i点伤害,又因为后面有k−1次跳过机会再减去k−1，把k提出来，考虑−a[i]+n−i,排序取前k个得出答案若跳过第i个陷阱，则减少伤害a[i]但其后面会增加n-i点伤害,又因为后面有k-1次跳过机会再减去k-1，把\\\\k提出来，考虑-a[i]+n-i,排序取前k个得出答案若跳过第i个陷阱，则减少伤害a[i]但其后面会增加n−i点伤害,又因为后面有k−1次跳过机会再减去k−1，把k提出来，考虑−a[i]+n−i,排序取前k个得出答案\n 793-Div2\n B\n题意：给定0～n-1的一个无序排列，现在可以任意交换aia_iai​和aja_jaj​任意多次，前提是ai&amp;aj=xa_i\\&amp;a_j=xai​&amp;aj​=x使得排列有序，求最大的x\n对于每个ai和i不同的位置，该元素必须要交换，在二进制的情况考虑，若ai的二进制位是0，x不可以为1，而为了取最大值ai二进制为1的位置，x尽量为1，综合考虑，将所有不符合条件的ai与起来得到x，x即为最大的，由于x在排列中，可借助中转站实现任意两个元素交换，a&amp;b&amp;c⋅⋅⋅=x,则a&amp;x=x对于每个a_i和i不同的位置，该元素必须要交换，在二进制的情况考虑，若a_i的二进制位是0，\\\\x不可以为1，而为了取最大值a_i二进制为1的位置，x尽量为1，\\\\综合考虑，将所有不符合条件的a_i与起来得到x，x即为最大的，\\\\由于x在排列中，可借助中转站实现任意两个元素交换，a\\&amp;b\\&amp;c···=x,则a\\&amp;x=x对于每个ai​和i不同的位置，该元素必须要交换，在二进制的情况考虑，若ai​的二进制位是0，x不可以为1，而为了取最大值ai​二进制为1的位置，x尽量为1，综合考虑，将所有不符合条件的ai​与起来得到x，x即为最大的，由于x在排列中，可借助中转站实现任意两个元素交换，a&amp;b&amp;c⋅⋅⋅=x,则a&amp;x=x\n C\n 810-Div2\n B\n有n个人，m对关系，每个人不来的话都有一个生气值，问使m为偶数获得的最小生气值（关系中任意一人不来关系消失\n只讨论m为奇数的情况如何变为偶数，很明显如果一个人所拥有的关系数是奇数个，这个人删掉就一定可以满足要求，所以首先找到生气值最小的拥有奇数个关系的人，其次在统计关系时直接取有关系二人生气和的最小值，由于奇数个关系找到的是生气值最小的那个人，所以如果取两个人的情况发生，不会有两个人中有一个是奇数个关系的人\n C\n","slug":"cf-792-div1-2","date":"2022-05-20T15:40:39.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3ae07ab74ec1bcb36882cc1ce0d929c6","title":"搜索","content":" 搜索剪枝\n 小木棍\n有一些同样长的小木棍，将这些木棍随意切割，得到若干小木棍，已知这些小木棍的长度，求最小的初始木棍原长\n1.搜索\n根据一根木棍的拼接来确定搜索的参数，设立：\n\n\n还有多少木棍没有进行拼接\n\n\n当前拼接的木棍还需要多少长度\n\n\n目标木棍长度\n\n\n现在处理第几根木棍\n\n\nvector&lt;int&gt; a(n + 1);\nvector&lt;bool&gt; vis(n + 1);&#x2F;&#x2F;利用vis数组来避免重复搜索\nbool dfs(int num, int rest, int len, int k)&#123;\n    if (num &#x3D;&#x3D; 0 &amp;&amp; rest &#x3D;&#x3D; 0)&#123;\n        return true;\n    &#125;\n    if (rest &#x3D;&#x3D; 0)&#123;\n        rest &#x3D; len;\n        k &#x3D; 1;\n    &#125;\n    for (int i &#x3D; k; i &lt;&#x3D; n; ++i)&#123;\n        if (!vis[i])&#123;\n            vis[i] &#x3D; 1;\n            if (dfs(num - 1, rest - a[i], len, i))&#123;\n                return true;\n            &#125;\n            vis[i] &#x3D; 0;\n        &#125;\n    &#125;\n    return false;\n&#125;\n2.剪枝\n顾名思义，减去解答树的部分“枝条”，对于正在拼接的一根木棍而言，如果第一根小木棍就不能满足或者作为最后一根小木棍满足但是后续不满足，就不用考虑其他的小木棍了，且与其长度相同的小木棍也不用考虑了，由此，可以先预处理将所有小木棍由高到低排序，再进行下列操作\n dfs\n递归搜索，将要搜索的目标分成若干层，每层基于前几层的状态进行决策，直到达到目标状态\n大致结构：\n&#x2F;&#x2F; u可以是节点或者一种抽象的状态\ndfs(u) &#123;\n  1.判断是否达到目标状态 -&gt; return;\n  2.标记u这个状态访问过了\n  3.for u 可以延伸到的状态 v：\n  \t  如果v没有被访问到\n  \t  dfs(v);\n  \tend\n  end\n&#125;\n 应用\n\n\n连通块的计算\n\n\n生成每一位都是7或4的数\nvector&lt;int&gt; pos;\nvoid dfs(int k)&#123;\n    pos.push_back(k);\n    dfs(k * 10 + 4);\n    dfs(k * 10 + 7);\n&#125;\ndfs(4);dfs(7);\n\n\n染色法\n\n\n bfs\n从每个状态节点一层一层的往外找，所以是寻找初始状态到目标状态最短距离的搜索手段\n大致结构：\nbfs()&#123;\n  1.将初始状态节点放入队列\n  2.标记初始状态节点为已访问过\n  while(队列不为空)&#123;\n    1.取队首状态节点\n    2如果是目标节点，直接返回累计的最短路长\n    3.这个状态能延伸到的节点v，如果没有被访问到 -&gt;bfs(v)\n  &#125;\n&#125;\n应用：\n\n\n字符串变换\n几个技巧：\n\n利用map&lt;string, node&gt; 可以同时储存状态本身的信息和状态是否被访问的信息，只需要在队列中入队string即可\nstring 字符串可以一维对应二维坐标，然后就像走迷宫一样改变状态\n\n\n\n状态设计\n当状态涉及到多个元素是否取得的时候而且n比较小, 可以用\nint ans &#x3D; 0;\nfor (int i &#x3D; 0; i &lt; n; ++i)&#123;\n    if (取)&#123;\n        ans |&#x3D; 1 &lt;&lt; i;\n    &#125;\n&#125;\n来用一个较大整数的二进制位数来确定状态\n\n\n状态确定\n\n\n给出一个地图，两个人同时从一个起点出发，问经过多长时间可以两人可以走完地图\n正常bfs，但需要考虑一点就是，状态的确定问题\nvis数组应该同时考虑两人的位置以及两人现在走过的地图大小，走过的地图大小可以坐标二维转化为一维然后通过二进制储存在一个较大的数里\n\n\n\n\n传送阵（改变状态转移方式的东西）\n\n\n传送阵可以选择传送也可以选择不传送\n\n\n优先队列bfs\n传送阵可以通过额外的时间传送到另一个位置\n\n\n0-1 bfs\n通过deque来使得队列一直取得最小值，即状态改变有多种选择但是平常不进行状态改变\n状态改变的节点放到后面先处理状态改变比较少的状态\n\n\n\n\n“传送阵”会永久改变状态改变方式而且必须踩到\n\n正常2秒一个格子，踩到车之后一秒一个格子，很明显，对于同一个位置没有车但步数少不一定最终强过有车但是暂时步数多，所以唯一区别点是有没有车，先做一个bfs找到不用车到达终点的步数，再找到所有车的最短路，再对每辆车重新做bfs和之前的加起来，比较\n迷宫中引入钥匙和门，同样的，先做bfs找到钥匙，不过这里不用做两次bfs，只需要在没有钥匙的时候对自己经过的点设置为门就可以了\n\n\n\n\n\n","slug":"搜索","date":"2022-05-12T00:57:55.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"c415bd8a15236b765141e56b25f1f835","title":"技巧","content":"$ 用逻辑尺来暴力枚举对于n个状态的取舍的2^n种情况 $\nfor (int i&#x3D;0;i&lt;(1&lt;&lt;n);++i)&#123;\n    for (int j&#x3D;0;j&lt;n;++i)&#123;\n        if(i&lt;&lt;j&amp;1)&#123;\n            operation();\n        &#125;\n    &#125;\n&#125;\n检查对角线元素，对于1⩽i⩽n，1⩽j⩽m，2⩽i+j⩽n+m，2⩽i−j+m+1⩽n+m检查对角线元素，对于1\\leqslant i\\leqslant n，1\\leqslant j\\leqslant m，2\\leqslant i+j\\leqslant n+m，2\\leqslant i-j+m+1\\leqslant n+m检查对角线元素，对于1⩽i⩽n，1⩽j⩽m，2⩽i+j⩽n+m，2⩽i−j+m+1⩽n+m\nint vis1[n+m+1]，int vis2[n+m+1]int\\ vis1[n+m+1]，int\\ vis2[n+m+1]int vis1[n+m+1]，int vis2[n+m+1]\n排序问题:\n部分解决方案：\n\n将数组重新排序，依次与之前的数组元素进行比较，一个乱的序列变为升序序列所需最少交换次数等于逆序对的个数，逆序对可通过归并排序或树状数组+离散化解决\n枚举某个一定会出现的元素的位置，在依据排序的法则构造有序数组\n对于区间覆盖问题，将起点和终点重新排序，再一一对应，所重新覆盖的区间和原本的一样\n\n构造题：\n\n满足{f(0)=0f(1)=1f(i)=f(i/2)+f(i%2)\\begin{cases}\n &amp;f(0)=0\\\\ \n &amp;f(1)=1\\\\ \n &amp;f(i)=f(i/2)+f(i\\%2) \n\\end{cases}⎩⎪⎨⎪⎧​​f(0)=0f(1)=1f(i)=f(i/2)+f(i%2)​f(x)f(x)f(x)表示x的二进制表达有多少个1\n\n对于平方数，我们发现其模4总是余1或者2\n","slug":"技巧","date":"2022-05-11T15:58:56.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3f75e6c48899ccc9cfffa214dd7d68de","title":"算法竞赛入门经典","content":" 1.如果一个字符串不存在两个相邻的重复子串，则字符串满足题意，求用前L个字母构成的，字典序排第n的子串\n暴力思路：检查所有偶数长度的子串，检查其是否为前缀后缀相同的子串\n优化思路：由于求字典序，只需判断当前字符串的所有后缀子串是否满足条件，从左往右推进，检查当前字符串\nint n,l,cnt;\nint a[100000];\nint dfs(int m)&#123;\n    if(cnt++&#x3D;&#x3D;n)&#123;\n        for (int i&#x3D;0;i&lt;m;++i)&#123;\n            cout&lt;&lt;(char)(&#39;A&#39;+a[i]);\n        &#125;\n        return 0;&#x2F;&#x2F;return 0代表已经找到字典序排第m的子串\n    &#125;\n    else&#123;\n        for (int i&#x3D;0;i&lt;l;++i)&#123;\n            a[m]&#x3D;i;\n            int ret&#x3D;1;&#x2F;&#x2F;判断当前串是否是想要的，即所有后缀子串均不合法\n            for (int j&#x3D;1;2*j&lt;&#x3D;m+1;++j)&#123;\n                int ok&#x3D;1;&#x2F;&#x2F;判断当前后缀子串是否合法，若合法则当前串不是想要的\n                for (int k&#x3D;0;k&lt;j;++k)&#123;\n                    if(a[m-k]!&#x3D;a[m-k-j])&#123;ok&#x3D;0;break;&#125;&#x2F;&#x2F;肯定不合法\n                &#125;\n                if(ok)&#123;ret&#x3D;0;break;&#125;\n            &#125;\n            if(ret)&#123;\n                if(!dfs(m+1))return 0;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n&#125;\n","slug":"算法竞赛入门经典","date":"2022-05-02T13:26:37.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"e24161b022b99e01e5ff1a820d3ba3c0","title":"cf-785-div2","content":" C\n 题意：给出一个数n，n可以用若干回文数之和的形式表示出来，求有多少种方法来表示\n 方法：\n先枚举回文数\nbool check(int x)&#123;\n  int n&#x3D;0,xx&#x3D;x;\n    while(x)&#123;\n        n&#x3D;n*10+s%10;\n        x&#x2F;&#x3D;10;\n    &#125;\n  \tif(x&#x3D;&#x3D;n) return 1;\n  \telse return 0;\n&#125;\nvector&lt;int&gt; mp;\nif(check(k))mp.oush)back(k);\n然后动态规划，dp(i)(j)dp(i)(j)dp(i)(j)代表用前j个数拼成i的方案有多少种\ndp[i][j]={1dp[i][j−1]dp[i][j−1]+dp[i−mp[j]][j]dp[i][j]={\\begin{cases}\n \\qquad1\\\\ \n dp[i][j-1]\\\\ \n dp[i][j-1]+dp[i-mp[j]][j]\n\\end{cases}}\ndp[i][j]=⎩⎪⎨⎪⎧​1dp[i][j−1]dp[i][j−1]+dp[i−mp[j]][j]​\n D\n 题意：已知给出一个等差数列的首项，公差，项数可以知道其全部信息，给出两个等差数列B，C的信息，已知C是B与另一等差数列A的共同元素组成的等差数列，求A可能的数目，其中数目为0，无穷大时要特判\n 方法：\n若不满足以下条件，则A的数目为0\n\nC被B完全覆盖\nC的公差是B的公差的倍数\nC的某一项要和B的第一项相同\n\n在A的数目不为0的前提下，若满足以下条件之一，则A的数目为无穷多个\n\nB的第一项大于C的第一项的前一项\nB的最后一项小于C的最后一项的后一项\n\n在满足A的数目不为无穷多个时，发现A的第一项必须要大于C的第一项的前一项，最后一项同理，同时仍要满足\nlcm(p,q)=rlcm(p,q)=rlcm(p,q)=r以及(c−a)modp=0(c-a)mod p=0(c−a)modp=0,枚举r的所有因数，则最终结果为ans=∑lcm(p,q)=r(rp)2ans=\\sum_{lcm(p,q)=r}(\\frac{r}{p})^2ans=∑lcm(p,q)=r​(pr​)2\n","slug":"cf-785-div2","date":"2022-05-02T01:26:10.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"1f95e29524cb1fc8f16f7dbdf365181a","title":"二叉堆","content":"&#x2F;&#x2F;手动实现\nvoid shift(int i)&#123;\n    while(1)&#123;\n        int l&#x3D;2*i;\n        if(l&lt;&#x3D;len-1&amp;&amp;a[l]&gt;a[l+1])l++;\n        if(l&gt;len||a[i]&lt;a[l]) break;\n        swap(a[i],a[l]);\n        i&#x3D;l;\n    &#125;\n&#125;\na[0]&#x3D;-1;&#x2F;&#x2F;堆的最顶层是最小的或者最大的\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;\n            cin&gt;&gt;x;a[++len]&#x3D;x;\n            int i&#x3D;len;\n            while(a[i]&lt;a[i&#x2F;2])&#123;\n                swap(a[i],a[i&#x2F;2]);\n                i&#x2F;&#x3D;2;\n            &#125;\n        &#125;&#x2F;&#x2F;新加入节点，放到最后一个，依次和父节点比较\n        else if(op&#x3D;&#x3D;2)&#123;\n            cout&lt;&lt;a[1]&lt;&lt;endl;\n        &#125;\n        else&#123;\n            swap(a[1],a[len--]);\n            for (int i&#x3D;len&#x2F;2;i&gt;&#x3D;1;--i)&#123;\n                shift(i);\n            &#125;\n        &#125;&#x2F;&#x2F;对于删除节点，将第一个元素和最后一个元素交换，然后从该节点的父节点一直到第一个节点依次向下更新\n    &#125;\n&#x2F;&#x2F;实现堆的简单方法-优先队列\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint n,op,x;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;1&quot;,&quot;r&quot;,stdin);freopen(&quot;2&quot;,&quot;w&quot;,stdout);\n    ios::sync_with_stdio(false);cin.tie(0);\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;x;q.push(x);&#125;\n        else if(op&#x3D;&#x3D;2) cout&lt;&lt;q.top()&lt;&lt;endl;\n        else q.pop();\n    &#125;\n&#125;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;小根堆\npriority_queue&lt;int&gt;大根堆\nq.top()&#x2F;&#x2F;取得堆顶元素，并不会弹出\nq.pop()&#x2F;&#x2F;弹出堆顶元素\nq.push()&#x2F;&#x2F;往堆里面插入一个元素\nq.empty()&#x2F;&#x2F;查询堆是否为空，为空则返回1否则返回0\nq.size()&#x2F;&#x2F;查询堆内元素数量\n","slug":"二叉堆","date":"2022-04-27T06:23:23.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"fa4d4536e5d7115952b0289a4a257f8c","title":"cf-783-div2","content":" C\n 题意：给出长度为n的序列a,长度为n的序列b中初始值全是0,每次操作可以让加上或者减去,问最少操作多少次才能使变成一个严格单调递增的序列.\n 方法：贪心的考虑，最终数组一定会有0存在，枚举0的位置，依次计算达到严格单调递增所需要移动的次数\nint main()&#123;\n    n&#x3D;read();\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i]&#x3D;read();\n    &#125;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        ll pre&#x3D;0,cnt&#x3D;0;\n        for (int j&#x3D;i+1;j&lt;&#x3D;n;++j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        pre&#x3D;0;\n        for (int j&#x3D;i-1;j&gt;&#x3D;1;--j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        cnt_min&#x3D;min(cnt_min,cnt);\n    &#125;\n    printf(&quot;%lld&quot;,cnt_min);\n&#125;\npre+=a[j]-pre%a[j]满足大于pre且是a[j]的倍数的最小值\n D\n 题意：有一个长度为n的序列a，可以将其切割成连续的若干子列，每部分子列得分如下\n\n如果子列和大于0，得分为子列的长度\n如果子列和等于0，得分为0\n如果子列和小于0，得分为子列的长度*-1\n\n 分析：\n","slug":"cf-783-div2","date":"2022-04-20T03:13:31.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"75693a8c6f85806ac837bdc72f35a1c0","title":"树状数组2","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500005\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int l,int r,ll k)&#123;\n    while(l&lt;&#x3D;n)&#123;\n        ans[l]+&#x3D;k;\n        l+&#x3D;l&amp;-l;\n    &#125;\n    r++;\n    while(r&lt;&#x3D;n)&#123;\n        ans[r]-&#x3D;k;\n        r+&#x3D;r&amp;-r;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,i,temp);\n    &#125;\n&#125;\n\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            x&#x3D;read();y&#x3D;read();ret&#x3D;read();\n            add(x,y,ret);\n        &#125;\n        else&#123;\n            x&#x3D;read();\n            printf(&quot;%lld\\n&quot;,sum(x));\n        &#125;\n    &#125;\n&#125;\n","slug":"树状数组2","date":"2022-04-19T08:42:09.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"a9af62bfd9db986968c6d2172b939d09","title":"树状数组1","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500001\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int x,ll k)&#123;\n    while(x&lt;&#x3D;n)&#123;\n        ans[x]+&#x3D;k;\n        x+&#x3D;x&amp;-x;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,temp);\n    &#125;\n&#125;\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();x&#x3D;read();y&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            add(x,y);\n        &#125;\n        else&#123;\n            printf(&quot;%lld\\n&quot;,sum(y)-sum(x-1));\n        &#125;\n    &#125;\n&#125;\n\n","slug":"树状数组1","date":"2022-04-19T06:36:42.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3a5edbaf2fab1786cda1ddc2eee70e29","title":"进制转换","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,ans;\nvoid otp(int x)&#123;\n    if(!x) return;\n    otp(x&#x2F;m);\n    char s&#x3D;x%m&gt;&#x3D;10?55+x%m:48+x%m;\n    putchar(s);\n&#125;\nint exe(char c)&#123;\n    return c&gt;&#x3D;65?c-55:c-48;\n&#125;\nint read()&#123;\n    int x&#x3D;0;\n    char c&#x3D;getchar();\n    for (;c&lt;48||c&gt;57&amp;&amp;c&lt;65||c&gt;70;c&#x3D;getchar())&#123;&#125;\n    for (;c&gt;&#x3D;48&amp;&amp;c&lt;&#x3D;57||c&gt;&#x3D;65&amp;&amp;c&lt;&#x3D;70;c&#x3D;getchar())&#123; x&#x3D;x*n+exe(c);&#125;\n    return x;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    ans&#x3D;read();\n    cin&gt;&gt;m;\n    otp(ans);\n&#125;\n","slug":"进制转换","date":"2022-04-06T05:30:25.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"5757d25a41334dab48eea89b5201dea3","title":"算法讲解","content":" 有向图强连通分量的Tarjan算法\nhttps://byvoid.com/zhs/blog/scc-tarjan/\n","slug":"算法讲解","date":"2022-04-05T07:34:09.000Z","categories_index":"教程","tags_index":"算法","author_index":"shallow"},{"id":"be4fadc0757b3a2eeaefd20302787665","title":"集合","content":" 题目要求\nCaima 给你了所有**[a,b]**范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 p的公共质因数，那么把它们所在的集合合并。重复如上操作，直到没有可以合并的集合为止。现在 Caima 想知道，最后有多少个集合。\n 输入格式\n一行三个整数,a,b,p\n 输出格式\n一个数，最终的集合数\n 源代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a,b,p;\nint fa[100001];\nbool prime[100001];\nint find(int x)&#123;\n    return fa[x]&#x3D;&#x3D;x?x:fa[x]&#x3D;find(fa[x]);\n&#125;\nint main()&#123;\n    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    int ans&#x3D;b-a+1;\n    for (int i&#x3D;a;i&lt;&#x3D;b;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n    for (int i&#x3D;2;i&lt;&#x3D;b;++i)&#123;\n        if(!prime[i])&#123;\n            if(i&gt;&#x3D;p)&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                    if(j-i&gt;&#x3D;a&amp;&amp;find(j-i)!&#x3D;find(j))&#123;\n                        ans--;\n                        fa[find(j)]&#x3D;find(j-i);\n                    &#125;\n                &#125;\n            &#125;\n            else&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;ans;\n&#125;\n","slug":"集合","date":"2022-04-04T04:58:47.000Z","categories_index":"程序设计","tags_index":"并查集,埃尔筛法","author_index":"shallow"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":" 并查集\n意义：\n可以表示某一类东西是同种类，可以表示连通块，可以表示某几件事情有关系，具体什么关系再设计一个维度计算\n\n食物链中的带权并查集，如果两个动物有关系，就划分到同一区域，具体什么关系再推导一下\n01字符串的某一子串的含1数量是奇数还是偶数，可以利用前缀的思想分成两段，则如果[x,y]的含1数是奇数则可表示为[0,x-1]含1数是奇数和[0,y]含1数是偶数有关系，或者表示为[0,x-1]含1数是偶数和[0,y]含1数是奇数有关系，这里的有关系就更直白的告诉你这两件事情会同时发生\nn个游戏机，某几个游戏机连到一起时就可以玩某个游戏，可以用map数组来实现，map数组里每个元素存放着某种游戏已经有几个机器连在一起了，（实际上是某个连通块随便找个父节点管理这个连通块的机器连通情况）当遇到新的链接时，将连通块小的连到大的上，同时更新连通块信息，小的连通块清除\n对于不给出关系而是直接给出若干点让你判断关系，如【NOIP2017奶酪】让你寻找能通上下的连通块，可以暴力每次都和之前的所有元素比较，也可以搜索直接找（对于这种题目觉得真没别的办法的话就直接暴力吧）\n有若干对犯人，两个监狱，每对犯人有一个仇恨值，该对犯人在同一个监狱仇恨值就会爆发，求爆发的最小仇恨值，从大到小排列，采用A和B的补集有关系来设计并查集，当两个人无法避免的在一起之后，输出答案\n\n并查集是一种用来管理元素分组情况的数据结构，并查集可以高效地进行如下操作：\n\n查询元素a和b是否属于同一组\n合并元素a和b所在的组\n\nint n;&#x2F;&#x2F;一共有n个数据\n\nint fa[max_n+1];&#x2F;&#x2F;保存每个结点的父亲节点，其中根的父结点是自己\nint h[max_n+1];&#x2F;&#x2F;保存树的高度，避免退化影响复杂度\n&#x2F;&#x2F;map&lt;int,int&gt;fa;\nvoid init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n&#125;&#x2F;&#x2F;初始化每个节点的父节点是自己\n\nint find(int x)&#123;\n    if(fa[x]&#x3D;&#x3D;x) return x;\n    else return fa[x]&#x3D;find(fa[x]);\n&#125;&#x2F;&#x2F;找一个节点的根节点，顺便把自己直接连到根节点上-路径压缩\n\n&#x2F;&#x2F;常规合并\nvoid common_unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    fa[x]&#x3D;y;\n&#125;\n&#x2F;&#x2F;启发式合并\nvoid unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    if(x!&#x3D;y)&#123;\n        if(h[x]&lt;h[y]) fa[x]&#x3D;y;\n        else fa[y]&#x3D;x;\n        if(h[x]&#x3D;&#x3D;h[y]) h[x]++;\n    &#125;\n&#125;&#x2F;&#x2F;高度小的树作为高度大的树的子节点，树的高度在两树相等的时候更新\n建立一个数据结构，满足以下操作\n\n插入一个数\n删除一个数\n查询序列未出现过的最小正整数\n\n方法：建立一个set表示未出现过的数的集合，设立一个数组或map表示插入的数出现过的次数，当出现过次数变为0时应该在set中加入该数，表示现在该数不存在\n利用重载()运算符，来使set容器中的部分元素成为一个整体，达到以一映多的目的\nstruct cmp&#123;\n    bool operator ()(const int a, const int b)&#123;\n        if(abs(a-b)&lt;&#x3D;k)return false;\n        return a&lt;b;\n    &#125;\n&#125;\nset&lt;int,cmp&gt;s;\n&#x2F;&#x2F;以下两种函数的运作方式是创造一个新的对象然后通过比较的方式在set中寻找满足条件的元素\ns.find(x);&#x2F;&#x2F;寻找与x相差不超过k的元素\ns.erase(x);&#x2F;&#x2F;将与x相差不超过k的元素全部删除\n","slug":"并查集","date":"2022-04-03T10:34:08.000Z","categories_index":"程序设计","tags_index":"并查集","author_index":"shallow"},{"id":"d78199dbabc681e201328dc8f8002dc2","title":"share","content":"","slug":"share","date":"2022-01-22T09:06:40.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":":::tip\n注意了，这是个tip\n:::\n:::tip 标题\n哈哈，自定义\n:::\n:::warning\n警告一次！\n:::\n:::details 点开看看\n你个傻逼\n:::\n","slug":"test","date":"2022-01-10T15:11:45.000Z","categories_index":"测试","tags_index":"开发者","author_index":"shallow"},{"id":"6181be25ee551197b04a134e589faeae","title":"年度总结","content":" 再见，2021\n 收获\n走过了一年，虽然一路上坎坎坷坷，但还是有很多快乐和值得纪念的事情😙\n\n我转专业成功了\n\n从机类转到计算机相关专业，虽然转专业之后的部分课程并不是我想象中的那么美好，但我还是觉得幸运，感谢当时果断做决定的自己。\n\n\n我参加了十四运会志愿者队伍\n\n对于一个普通人而言，能够参加这样的盛会是件非常高兴的事情，对我而言也确实如此。\n我记得西铁院下午的阳光，食堂门口的喷泉因此有了五彩的颜色。\n我记得体育馆凌晨的月光，我们度过了近20天不眠的夜晚。\n我记得机动队的四个人，一个下午分发了3万份的物资。\n我记得司机师傅的疲惫的笑容，和作为安全员的我送了一批又一批的演员前往排练。\n我当然还记得那时的火炬，仿佛要驱散一切阴霾似得，燃的热烈。正像大雨中的我们，虽然疲惫不堪却笑容满面，这种充满无私奉献，乐观主义的奋斗精神很难不让人热泪盈眶。\n\n\n我选择了很棒的技术社团和菁英班\n\n在RM的日子让我受益匪浅，我认识了很多优秀的学长和同龄人，和他们共同努力真的是件很棒的事，虽然自己在新知识的学习上愚笨而且懈怠，但也算是有所收获，希望2022年RM校队打破队史，再创佳绩！\n通过百度大数据人工智能菁英班的选拔是在我意料之外的事情，希望自己能对得起着来自不易的机会，在未来一周年的培养计划中向大佬们学习，不愧对这份幸运。\n\n\n\n 遗憾\n又是一年风雨兼程，今年的我又有怎样的感叹呢🥲\n\n我还需要更成熟\n\n都说性格决定命运，以前我是不信的，现在倒有点相信了。由于我的没心没肺，错过了很多可能改编我人生轨迹的事情，在与人交往的过程中也有很多不当之处，希望未来的自己能够严于律己，凡事三思而后行。\n\n\n我还需要更勇敢\n\n还记得去年这个时候我在华山许愿，希望自己的2021年变得勇敢，能够万事胜意，。我也确实做到了一部分，可我还是觉得远远不够，对于一些毫无把握的事我也许可以再尝试尝试，万一就出现转机了呢，对于现在一无所有的我而言，如果再不够勇敢那就真的什么都不剩下了，希望未来一年不要错过一切我在意的东西。\n\n\n我还需要更自律\n\n过度沉迷手机，刷一些无意义的内容占用了我大量的休息时间，它们原本可以有更好的安排，但我没有这样做，也许这种事后诸葛亮的呻吟可能一点用处都没有，但我还是希望自己可以更加自律，合理安排自己的生活。\n\n\n\n 你好，2022\n 期望\n\n学业成绩和竞赛不留遗憾，戒骄戒躁，珍惜大学本科时光。\n生活不留遗憾，依然要投身志愿活动中，那是我一直坚持的。\n对自己不留遗憾，对于在意的事情要努力去争取。\n\n\n 那么新年第一条愿望，就是祝看到这个博客的你2022得偿所愿，日日顺心🥰\n","slug":"my2021","date":"2021-12-31T13:12:12.000Z","categories_index":"总结","tags_index":"开发者","author_index":"shallow"},{"id":"b48181ff5fc549c282670b2e3976c524","title":"PTA数据结构08","content":" 题目要求\n​\t\t因为一棵二叉树的遍历可以用堆栈来模拟，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出\n Input Specification:\n6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\n Output Specification:\n3 4 2 6 5 1\n 解析：\n​\t\t首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为\ntypedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;\n​\t\t接下来考虑Push和Pop的对应操作该如何实现\nPush：对于一个结点优先访问其左子树，其次右子树\nPop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作\n 完整代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s\n","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","categories_index":"题目集","tags_index":"PTA,树","author_index":"shallow"},{"id":"c64fb311e63f4c1eefb237f294f60a66","title":"PTA数据结构05","content":" 题目要求\n给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出&quot;YES&quot;,否则&quot;NO&quot;\n Input Specification:\n第一行依次为M、N、K，后跟K行样例\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n Output Specification:\nYES\nNO\nNO\nYES\nNO\n 解析\n由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止\n显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期\n 示例代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;\n","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","categories_index":"题目集","tags_index":"PTA,线性结构","author_index":"shallow"},{"id":"1f2e6374a67016c059eddb723ab0efc5","title":"博客介绍","content":" 这是一个怎样的博客？\n 博客性质\n\n个人博客，分享生活感悟\n记录博客，分享学习心得\n\n 你能在这里收获什么\n\n了解开发者的心路历程，与开发者共情（反正就是好朋友 😠）\n学习上获得帮助：本站主要是技术内容的分享\n\n 如何使用本站？\n\n通过tag或category标签来检索内容\n合理设置关键字，在搜索框中进行检索\n\n 还没想好\n\n未完待续\n未完待续\n未完待续\n\n","slug":"博客介绍","date":"2021-11-26T05:38:30.000Z","categories_index":"教程","tags_index":"开发者,入站必读","author_index":"shallow"}]