[{"id":"1840725987698b4cef5a9ce40df0584c","title":"队列","content":"栈出栈排序给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序\n对当前元素入队，如果栈顶元素大于之后的所有元素，出栈\n队列插队给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进队后出队\n解答：设计一个队列，如果一个人没有插队一定是当他出队时正好在队伍的开头，即前面的所有人都已经出队。出队时，如果正好这个人在队头，出队，否则，标记这个人已经离开队伍，且插队的人数加一，在每次判断队头的人是不是已经出队之前先用while循环删除已经出队的人\n前后调对于一个给定的序列，有两种操作，一个是将某元素移到队头，一个是将某元素移到队尾，问若干次移动后队列长啥样\n对每个元素x而言，设立数组p[x]=i,另设队头，队尾指针l=1，r=n每次移动元素时直接p[x]=l—或p[x]=r++;最后直接用p[x]的大小排序\n单调队列建立一个队列，队列中元素单调且满足其中的最大值是当前覆盖区间的最大值，最小值是尾元素，换言之，一个元素只有在有更大的元素入队时才会被删除\n模版\n判断队头元素是否需要出队\n使用队头的最值\n判断队尾元素是否需要出队\n队尾插入新元素的下标\n\n滑动窗口int k;&#x2F;&#x2F;滑动窗口维护最大值，k为窗口长度\nvector&lt;int&gt;a(n+1);&#x2F;&#x2F;元素容器\ndeque&lt;pair&lt;int,int&gt;&gt;q;&#x2F;&#x2F;&#123;序号，值&#125;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(!q.empty()&amp;&amp;q.back().second&lt;a[i].second)&#123;\n        q.pop_back();\n    &#125;\n    q.push_back(&#123;i,a[i]&#125;);\n    if(q.front().first&#x3D;&#x3D;k+x-1)&#123;\n        q.pop_front();\n    &#125;\n    if(i&gt;&#x3D;k)&#123;\n        cout&lt;&lt;q.front()&lt;&lt;&#39;\\n&#39;;\n    &#125;\n&#125;\n连续子序列最大和:给出一个序列，求出子序列长度不超过m的最大子序列和先用前缀数组预处理给定的序列，将sum[0]=0同样算入，对于 i&gt;=m，考虑$k \\epsilon [i-m,i-1]$这个区间，通过$sum[i]-sum[k]$则实现了寻找右边界为i长度不超过m的子序列最大和（只需要找到sum[k]的最小值即可），对于区间移动则可以用单调队列来解决\nint m;&#x2F;&#x2F;序列最大长度\nvector&lt;int&gt;sum(n+1);&#x2F;&#x2F;预处理前缀和数组\ndeque&lt;pair&lt;int,int&gt; &gt;q;\nq.push(&#123;sum[0],0&#125;);\nint ans&#x3D;-0x7fffffff;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(q.size()&amp;&amp;q.back().first&gt;sum[i])q.pop_back();\n    if(i&gt;&#x3D;m)&#123;\n        ans&#x3D;max(ans,sum[i]-sum[q.front().second]);\n    &#125;\n    q.push_back(&#123;sum[i],i&#125;);\n    if(q.front().second&#x3D;&#x3D;i-m+1)q.pop_front();\n    cout&lt;&lt;ans&lt;&lt;&#39;\\n&#39;;\n&#125;\n单调栈寻找某一个元素作为最大值或最小值，向左或向右扩展的区间\nex:\nstack&lt;pair&lt;int,int&gt; &gt;s;&#x2F;&#x2F;(a[i],i)\nvector&lt;int&gt;r(n+1);&#x2F;&#x2F;作为最大值扩展区间的右边界\nfor(int i&#x3D;n;i&gt;&#x3D;1;--i)&#123;\n    while(!s.empty()&amp;&amp;s.top().first&lt;a[i])s.pop();\n    if(s.empty())r[i]&#x3D;n;\n    else r[i]&#x3D;s.top().second-1;\n    s.push(&#123;a[i],i&#125;);\n&#125;\n区区区间间间定义价值为一个区间最大值-最小值\n求所有长度大于2区间的价值总和\n跑两遍单调栈，对于每个元素，其作为端点管理的区间加上其作为区间内管理的区间，值得注意的是跑两遍中，应有一遍不加等号一遍加，这样在出现相同元素相邻时一个元素只作为端点管理一边，而一个元素会管理另一边，杜绝了区间重复发生\n","slug":"队列","date":"2022-06-22T04:50:06.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"cf16dcad745c39bc496f066c73c8929e","title":"特殊的数据结构","content":"维护序列中最小未出现过的非负整数，支持插入，查询，删除用一个数组记录每个数出现过的次数，用set维护一个按大小排列的未出现过数\nint cot[maxnum];\nset&lt;int&gt;st;\nint m;\nint op, x;\nvoid solve() &#123;\n\tfor (int i &#x3D; 0; i &lt; maxnum; i++)st.insert(i);\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tcin &gt;&gt; op;\n\t\tif (op &#x3D;&#x3D; 0) &#123;\n\t\t\tcin &gt;&gt; x;\n\t\t\tif (cot[x] &#x3D;&#x3D; 0) &#123;\n\t\t\t\tst.erase(x);\n\t\t\t&#125;\n\t\t\tcot[x]++;\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; 1) &#123;\n\t\t\tcout &lt;&lt; *st.begin() &lt;&lt; endl;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcin &gt;&gt; x;\n\t\t\tif (cot[x] &#x3D;&#x3D; 1) &#123;\n\t\t\t\tst.insert(x);\n\t\t\t&#125;\n\t\t\tcot[x]--;\n\t\t&#125;\n\t&#125;\n\n&#125;\n","slug":"特殊的数据结构","date":"2022-05-21T14:49:59.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"ec879031a4be3590103f0fd58b750e46","title":"cf-792-div1+2","content":"C题意：给定一个矩阵，你可以将任意两列交换至多一次，问能否使矩阵每一行不下降\n方法：读入矩阵，对每一行重新排序，若与原序列不同则加入有问题数组，数组长度大于2则不可能交换一次解决，否则将矩阵交换该两列，看是否满足答案\n题意：给定一个2行n列的矩阵，可以任意交换两列，问能否使矩阵的每一行都不下降\nD题意：给定n个陷阱，你需要按顺序走过这些陷阱，每个陷阱会对你造成固定伤害，你可以跳过k个陷阱，但是每跳过一个陷阱后续所有的陷阱造成的伤害都会加一，求走完n个陷阱所受到的最小伤害\n方法：\n首先贪心的考虑一定要用完所有跳过的机会，如果不想让后面的陷阱变大跳过最后一个便是了，其次考虑跳过每个陷阱所减少的伤害数：\n$若跳过第i个陷阱，则减少伤害a[i]但其后面会增加n-i点伤害,又因为后面有k-1次跳过机会再减去k-1，把\\\\k提出来，考虑-a[i]+n-i,排序取前k个得出答案$\n793-Div2B题意：给定0～n-1的一个无序排列，现在可以任意交换$a_i$和$a_j$任意多次，前提是$a_i\\&amp;a_j=x$使得排列有序，求最大的x\n$对于每个a_i和i不同的位置，该元素必须要交换，在二进制的情况考虑，若a_i的二进制位是0，\\\\x不可以为1，而为了取最大值a_i二进制为1的位置，x尽量为1，\\\\综合考虑，将所有不符合条件的a_i与起来得到x，x即为最大的，\\\\由于x在排列中，可借助中转站实现任意两个元素交换，a\\&amp;b\\&amp;c···=x,则a\\&amp;x=x$\nC","slug":"cf-792-div1-2","date":"2022-05-20T15:40:39.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3ae07ab74ec1bcb36882cc1ce0d929c6","title":"搜索","content":"搜索剪枝小木棍有一些同样长的小木棍，将这些木棍随意切割，得到若干小木棍，已知这些小木棍的长度，求最小的初始木棍原长\n1.搜索\n根据一根木棍的拼接来确定搜索的参数，设立：\n\n还有多少木棍没有进行拼接\n\n当前拼接的木棍还需要多少长度\n\n目标木棍长度\n现在处理第几根木棍\n\nvector&lt;int&gt; a(n + 1);\nvector&lt;bool&gt; vis(n + 1);&#x2F;&#x2F;利用vis数组来避免重复搜索\nbool dfs(int num, int rest, int len, int k)&#123;\n    if (num &#x3D;&#x3D; 0 &amp;&amp; rest &#x3D;&#x3D; 0)&#123;\n        return true;\n    &#125;\n    if (rest &#x3D;&#x3D; 0)&#123;\n        rest &#x3D; len;\n        k &#x3D; 1;\n    &#125;\n    for (int i &#x3D; k; i &lt;&#x3D; n; ++i)&#123;\n        if (!vis[i])&#123;\n            vis[i] &#x3D; 1;\n            if (dfs(num - 1, rest - a[i], len, i))&#123;\n                return true;\n            &#125;\n            vis[i] &#x3D; 0;\n        &#125;\n    &#125;\n    return false;\n&#125;\n2.剪枝\n顾名思义，减去解答树的部分“枝条”，对于正在拼接的一根木棍而言，如果第一根小木棍就不能满足或者作为最后一根小木棍满足但是后续不满足，就不用考虑其他的小木棍了，且与其长度相同的小木棍也不用考虑了，由此，可以先预处理将所有小木棍由高到低排序，再进行下列操作\n","slug":"搜索","date":"2022-05-12T00:57:55.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"c415bd8a15236b765141e56b25f1f835","title":"技巧","content":"$ 用逻辑尺来暴力枚举对于n个状态的取舍的2^n种情况 $\nfor (int i&#x3D;0;i&lt;(1&lt;&lt;n);++i)&#123;\n    for (int j&#x3D;0;j&lt;n;++i)&#123;\n        if(i&lt;&lt;j&amp;1)&#123;\n            operation();\n        &#125;\n    &#125;\n&#125;\n$检查对角线元素，对于1\\leqslant i\\leqslant n，1\\leqslant j\\leqslant m，2\\leqslant i+j\\leqslant n+m，2\\leqslant i-j+m+1\\leqslant n+m$\n$int\\ vis1[n+m+1]，int\\ vis2[n+m+1]$\n排序问题:\n部分解决方案：\n\n将数组重新排序，依次与之前的数组元素进行比较，一个乱的序列变为升序序列所需最少交换次数等于逆序对的个数，逆序对可通过归并排序或树状数组+离散化解决\n枚举某个一定会出现的元素的位置，在依据排序的法则构造有序数组\n对于区间覆盖问题，将起点和终点重新排序，再一一对应，所重新覆盖的区间和原本的一样\n\n构造题：\n\n满足$\\begin{cases} &amp;f(0)=0\\\\ &amp;f(1)=1\\\\ &amp;f(i)=f(i/2)+f(i\\%2)\\end{cases}$$f(x)$表示x的二进制表达有多少个1\n\n后缀表达式：从头到尾遍历，取两个数字，取一个符号，运算，放入栈中，直到只剩一个数字在栈中\n字符串查找find()函数：\nint cnt;\nstring s,t;\nif((cnt&#x3D;s.find(t))!&#x3D;string::npos)cout&lt;&lt;&quot;get!&quot;&lt;&lt;&#39;\\n&#39;;\nelse cout&lt;&lt;&quot;can&#39;t get!&quot;&lt;&lt;&#39;\\n&#39;;\ndeque有sort方法\n","slug":"技巧","date":"2022-05-11T15:58:56.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"lower_bound()与upper_bound()&#x2F;&#x2F;对于结构体重载例如\nstruct op&#123;\n    int elem,id;\n    op(int a,int b)&#123;elem&#x3D;a;id&#x3D;b;&#125;\n    bool operator&lt;(const op&amp;a)const&#123;\n        if(elem&#x3D;&#x3D;a.elem)return id&lt;a.id;\n        return elem&gt;a.elem;\n    &#125;\n&#125;\n&#x2F;&#x2F;标程解读：按elem大小从高到低排列，对于相同elem的而言id小的在前\n二分答案一些经典转化例子：\n\n$第m大的数为x\\Leftrightarrow 至少有m个数大于等于x$\n\n\n","slug":"二分查找","date":"2022-05-03T14:28:29.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3f75e6c48899ccc9cfffa214dd7d68de","title":"算法竞赛入门经典","content":"1.如果一个字符串不存在两个相邻的重复子串，则字符串满足题意，求用前L个字母构成的，字典序排第n的子串暴力思路：检查所有偶数长度的子串，检查其是否为前缀后缀相同的子串\n优化思路：由于求字典序，只需判断当前字符串的所有后缀子串是否满足条件，从左往右推进，检查当前字符串\nint n,l,cnt;\nint a[100000];\nint dfs(int m)&#123;\n    if(cnt++&#x3D;&#x3D;n)&#123;\n        for (int i&#x3D;0;i&lt;m;++i)&#123;\n            cout&lt;&lt;(char)(&#39;A&#39;+a[i]);\n        &#125;\n        return 0;&#x2F;&#x2F;return 0代表已经找到字典序排第m的子串\n    &#125;\n    else&#123;\n        for (int i&#x3D;0;i&lt;l;++i)&#123;\n            a[m]&#x3D;i;\n            int ret&#x3D;1;&#x2F;&#x2F;判断当前串是否是想要的，即所有后缀子串均不合法\n            for (int j&#x3D;1;2*j&lt;&#x3D;m+1;++j)&#123;\n                int ok&#x3D;1;&#x2F;&#x2F;判断当前后缀子串是否合法，若合法则当前串不是想要的\n                for (int k&#x3D;0;k&lt;j;++k)&#123;\n                    if(a[m-k]!&#x3D;a[m-k-j])&#123;ok&#x3D;0;break;&#125;&#x2F;&#x2F;肯定不合法\n                &#125;\n                if(ok)&#123;ret&#x3D;0;break;&#125;\n            &#125;\n            if(ret)&#123;\n                if(!dfs(m+1))return 0;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n&#125;\n","slug":"算法竞赛入门经典","date":"2022-05-02T13:26:37.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"e24161b022b99e01e5ff1a820d3ba3c0","title":"cf-785-div2","content":"C题意：给出一个数n，n可以用若干回文数之和的形式表示出来，求有多少种方法来表示方法：先枚举回文数\nbool check(int x)&#123;\n  int n&#x3D;0,xx&#x3D;x;\n    while(x)&#123;\n        n&#x3D;n*10+s%10;\n        x&#x2F;&#x3D;10;\n    &#125;\n  \tif(x&#x3D;&#x3D;n) return 1;\n  \telse return 0;\n&#125;\nvector&lt;int&gt; mp;\nif(check(k))mp.oush)back(k);\n然后动态规划，$dp(i)(j)$代表用前j个数拼成i的方案有多少种\n\ndp[i][j]={\\begin{cases}\n \\qquad1\\\\ \n dp[i][j-1]\\\\ \n dp[i][j-1]+dp[i-mp[j]][j]\n\\end{cases}}D题意：已知给出一个等差数列的首项，公差，项数可以知道其全部信息，给出两个等差数列B，C的信息，已知C是B与另一等差数列A的共同元素组成的等差数列，求A可能的数目，其中数目为0，无穷大时要特判方法：若不满足以下条件，则A的数目为0\n\nC被B完全覆盖\nC的公差是B的公差的倍数\nC的某一项要和B的第一项相同\n\n在A的数目不为0的前提下，若满足以下条件之一，则A的数目为无穷多个\n\nB的第一项大于C的第一项的前一项\nB的最后一项小于C的最后一项的后一项\n\n在满足A的数目不为无穷多个时，发现A的第一项必须要大于C的第一项的前一项，最后一项同理，同时仍要满足\n$lcm(p,q)=r$以及$(c-a)mod p=0$,枚举r的所有因数，则最终结果为$ans=\\sum_{lcm(p,q)=r}(\\frac{r}{p})^2$\n","slug":"cf-785-div2","date":"2022-05-02T01:26:10.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"1f95e29524cb1fc8f16f7dbdf365181a","title":"二叉堆","content":"&#x2F;&#x2F;手动实现\nvoid shift(int i)&#123;\n    while(1)&#123;\n        int l&#x3D;2*i;\n        if(l&lt;&#x3D;len-1&amp;&amp;a[l]&gt;a[l+1])l++;\n        if(l&gt;len||a[i]&lt;a[l]) break;\n        swap(a[i],a[l]);\n        i&#x3D;l;\n    &#125;\n&#125;\na[0]&#x3D;-1;&#x2F;&#x2F;堆的最顶层是最小的或者最大的\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;\n            cin&gt;&gt;x;a[++len]&#x3D;x;\n            int i&#x3D;len;\n            while(a[i]&lt;a[i&#x2F;2])&#123;\n                swap(a[i],a[i&#x2F;2]);\n                i&#x2F;&#x3D;2;\n            &#125;\n        &#125;&#x2F;&#x2F;新加入节点，放到最后一个，依次和父节点比较\n        else if(op&#x3D;&#x3D;2)&#123;\n            cout&lt;&lt;a[1]&lt;&lt;endl;\n        &#125;\n        else&#123;\n            swap(a[1],a[len--]);\n            for (int i&#x3D;len&#x2F;2;i&gt;&#x3D;1;--i)&#123;\n                shift(i);\n            &#125;\n        &#125;&#x2F;&#x2F;对于删除节点，将第一个元素和最后一个元素交换，然后从该节点的父节点一直到第一个节点依次向下更新\n    &#125;\n&#x2F;&#x2F;实现堆的简单方法-优先队列\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint n,op,x;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;1&quot;,&quot;r&quot;,stdin);freopen(&quot;2&quot;,&quot;w&quot;,stdout);\n    ios::sync_with_stdio(false);cin.tie(0);\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;x;q.push(x);&#125;\n        else if(op&#x3D;&#x3D;2) cout&lt;&lt;q.top()&lt;&lt;endl;\n        else q.pop();\n    &#125;\n&#125;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;小根堆\npriority_queue&lt;int&gt;大根堆\nq.top()&#x2F;&#x2F;取得堆顶元素，并不会弹出\nq.pop()&#x2F;&#x2F;弹出堆顶元素\nq.push()&#x2F;&#x2F;往堆里面插入一个元素\nq.empty()&#x2F;&#x2F;查询堆是否为空，为空则返回1否则返回0\nq.size()&#x2F;&#x2F;查询堆内元素数量\n","slug":"二叉堆","date":"2022-04-27T06:23:23.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"fa4d4536e5d7115952b0289a4a257f8c","title":"cf-783-div2","content":"C题意：给出长度为n的序列a,长度为n的序列b中初始值全是0,每次操作可以让加上或者减去,问最少操作多少次才能使变成一个严格单调递增的序列.方法：贪心的考虑，最终数组一定会有0存在，枚举0的位置，依次计算达到严格单调递增所需要移动的次数int main()&#123;\n    n&#x3D;read();\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i]&#x3D;read();\n    &#125;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        ll pre&#x3D;0,cnt&#x3D;0;\n        for (int j&#x3D;i+1;j&lt;&#x3D;n;++j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        pre&#x3D;0;\n        for (int j&#x3D;i-1;j&gt;&#x3D;1;--j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        cnt_min&#x3D;min(cnt_min,cnt);\n    &#125;\n    printf(&quot;%lld&quot;,cnt_min);\n&#125;\npre+=a[j]-pre%a[j]满足大于pre且是a[j]的倍数的最小值\nD题意：有一个长度为n的序列a，可以将其切割成连续的若干子列，每部分子列得分如下\n如果子列和大于0，得分为子列的长度\n如果子列和等于0，得分为0\n如果子列和小于0，得分为子列的长度*-1\n\n分析：","slug":"cf-783-div2","date":"2022-04-20T03:13:31.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"75693a8c6f85806ac837bdc72f35a1c0","title":"树状数组2","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500005\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int l,int r,ll k)&#123;\n    while(l&lt;&#x3D;n)&#123;\n        ans[l]+&#x3D;k;\n        l+&#x3D;l&amp;-l;\n    &#125;\n    r++;\n    while(r&lt;&#x3D;n)&#123;\n        ans[r]-&#x3D;k;\n        r+&#x3D;r&amp;-r;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,i,temp);\n    &#125;\n&#125;\n\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            x&#x3D;read();y&#x3D;read();ret&#x3D;read();\n            add(x,y,ret);\n        &#125;\n        else&#123;\n            x&#x3D;read();\n            printf(&quot;%lld\\n&quot;,sum(x));\n        &#125;\n    &#125;\n&#125;\n","slug":"树状数组2","date":"2022-04-19T08:42:09.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"a9af62bfd9db986968c6d2172b939d09","title":"树状数组1","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500001\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int x,ll k)&#123;\n    while(x&lt;&#x3D;n)&#123;\n        ans[x]+&#x3D;k;\n        x+&#x3D;x&amp;-x;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,temp);\n    &#125;\n&#125;\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();x&#x3D;read();y&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            add(x,y);\n        &#125;\n        else&#123;\n            printf(&quot;%lld\\n&quot;,sum(y)-sum(x-1));\n        &#125;\n    &#125;\n&#125;\n\n","slug":"树状数组1","date":"2022-04-19T06:36:42.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"a8700b1bec2379b19ad66ea321a2af93","title":"线性筛模版","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,q,k,cnt;\nbool isprime[100000001];\nint prime[100000001];\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;q;\n    for (int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;\n        if(!isprime[i])&#123;\n            prime[++cnt]&#x3D;i;\n        &#125;\n        for (int j&#x3D;1;j&lt;&#x3D;cnt&amp;&amp;prime[j]*i&lt;&#x3D;n;++j)&#123;\n            isprime[prime[j]*i]&#x3D;1;\n            if(i%prime[j]&#x3D;&#x3D;0) break;\n        &#125;\n    &#125;\n    while(q--)&#123;\n        cin&gt;&gt;k;\n        cout&lt;&lt;prime[k]&lt;&lt;endl;\n    &#125;\n&#125;\n","slug":"线性筛模版","date":"2022-04-08T05:46:50.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3a5edbaf2fab1786cda1ddc2eee70e29","title":"进制转换","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,ans;\nvoid otp(int x)&#123;\n    if(!x) return;\n    otp(x&#x2F;m);\n    char s&#x3D;x%m&gt;&#x3D;10?55+x%m:48+x%m;\n    putchar(s);\n&#125;\nint exe(char c)&#123;\n    return c&gt;&#x3D;65?c-55:c-48;\n&#125;\nint read()&#123;\n    int x&#x3D;0;\n    char c&#x3D;getchar();\n    for (;c&lt;48||c&gt;57&amp;&amp;c&lt;65||c&gt;70;c&#x3D;getchar())&#123;&#125;\n    for (;c&gt;&#x3D;48&amp;&amp;c&lt;&#x3D;57||c&gt;&#x3D;65&amp;&amp;c&lt;&#x3D;70;c&#x3D;getchar())&#123; x&#x3D;x*n+exe(c);&#125;\n    return x;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    ans&#x3D;read();\n    cin&gt;&gt;m;\n    otp(ans);\n&#125;\n","slug":"进制转换","date":"2022-04-06T05:30:25.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"5757d25a41334dab48eea89b5201dea3","title":"算法讲解","content":"有向图强连通分量的Tarjan算法https://byvoid.com/zhs/blog/scc-tarjan/\n","slug":"算法讲解","date":"2022-04-05T07:34:09.000Z","categories_index":"教程","tags_index":"算法","author_index":"shallow"},{"id":"be4fadc0757b3a2eeaefd20302787665","title":"集合","content":"题目要求Caima 给你了所有[a,b]范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 p的公共质因数，那么把它们所在的集合合并。重复如上操作，直到没有可以合并的集合为止。现在 Caima 想知道，最后有多少个集合。\n输入格式一行三个整数,a,b,p\n输出格式一个数，最终的集合数\n源代码#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a,b,p;\nint fa[100001];\nbool prime[100001];\nint find(int x)&#123;\n    return fa[x]&#x3D;&#x3D;x?x:fa[x]&#x3D;find(fa[x]);\n&#125;\nint main()&#123;\n    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    int ans&#x3D;b-a+1;\n    for (int i&#x3D;a;i&lt;&#x3D;b;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n    for (int i&#x3D;2;i&lt;&#x3D;b;++i)&#123;\n        if(!prime[i])&#123;\n            if(i&gt;&#x3D;p)&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                    if(j-i&gt;&#x3D;a&amp;&amp;find(j-i)!&#x3D;find(j))&#123;\n                        ans--;\n                        fa[find(j)]&#x3D;find(j-i);\n                    &#125;\n                &#125;\n            &#125;\n            else&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;ans;\n&#125;\n","slug":"集合","date":"2022-04-04T04:58:47.000Z","categories_index":"程序设计","tags_index":"并查集,埃尔筛法","author_index":"shallow"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集意义：\n可以表示某一类东西是同种类，可以表示连通块，可以表示某几件事情有关系，具体什么关系再设计一个维度计算\n\n食物链中的带权并查集，如果两个动物有关系，就划分到同一区域，具体什么关系再推导一下\n01字符串的某一子串的含1数量是奇数还是偶数，可以利用前缀的思想分成两段，则如果[x,y]的含1数是奇数则可表示为[0,x-1]含1数是奇数和[0,y]含1数是偶数有关系，或者表示为[0,x-1]含1数是偶数和[0,y]含1数是奇数有关系，这里的有关系就更直白的告诉你这两件事情会同时发生\nn个游戏机，某几个游戏机连到一起时就可以玩某个游戏，可以用map数组来实现，map数组里每个元素存放着某种游戏已经有几个机器连在一起了，（实际上是某个连通块随便找个父节点管理这个连通块的机器连通情况）当遇到新的链接时，将连通块小的连到大的上，同时更新连通块信息，小的连通块清除\n对于不给出关系而是直接给出若干点让你判断关系，如【NOIP2017奶酪】让你寻找能通上下的连通块，可以暴力每次都和之前的所有元素比较，也可以搜索直接找（对于这种题目觉得真没别的办法的话就直接暴力吧）\n\n并查集是一种用来管理元素分组情况的数据结构，并查集可以高效地进行如下操作：\n\n查询元素a和b是否属于同一组\n合并元素a和b所在的组\n\nint n;&#x2F;&#x2F;一共有n个数据\n\nint fa[max_n+1];&#x2F;&#x2F;保存每个结点的父亲节点，其中根的父结点是自己\nint h[max_n+1];&#x2F;&#x2F;保存树的高度，避免退化影响复杂度\n&#x2F;&#x2F;map&lt;int,int&gt;fa;\nvoid init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n&#125;&#x2F;&#x2F;初始化每个节点的父节点是自己\n\nint find(int x)&#123;\n    if(fa[x]&#x3D;&#x3D;x) return x;\n    else return fa[x]&#x3D;find(fa[x]);\n&#125;&#x2F;&#x2F;找一个节点的根节点，顺便把自己直接连到根节点上-路径压缩\n\n&#x2F;&#x2F;常规合并\nvoid common_unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    fa[x]&#x3D;y;\n&#125;\n&#x2F;&#x2F;启发式合并\nvoid unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    if(x!&#x3D;y)&#123;\n        if(h[x]&lt;h[y]) fa[x]&#x3D;y;\n        else fa[y]&#x3D;x;\n        if(h[x]&#x3D;&#x3D;h[y]) h[x]++;\n    &#125;\n&#125;&#x2F;&#x2F;高度小的树作为高度大的树的子节点，树的高度在两树相等的时候更新\n建立一个数据结构，满足以下操作\n\n插入一个数\n删除一个数\n查询序列未出现过的最小正整数\n\n方法：建立一个set表示未出现过的数的集合，设立一个数组或map表示插入的数出现过的次数，当出现过次数变为0时应该在set中加入该数，表示现在该数不存在\n利用重载()运算符，来使set容器中的部分元素成为一个整体，达到以一映多的目的\nstruct cmp&#123;\n    bool operator ()(const int a, const int b)&#123;\n        if(abs(a-b)&lt;&#x3D;k)return false;\n        return a&lt;b;\n    &#125;\n&#125;\nset&lt;int,cmp&gt;s;\n&#x2F;&#x2F;以下两种函数的运作方式是创造一个新的对象然后通过比较的方式在set中寻找满足条件的元素\ns.find(x);&#x2F;&#x2F;寻找与x相差不超过k的元素\ns.erase(x);&#x2F;&#x2F;将与x相差不超过k的元素全部删除\n","slug":"并查集","date":"2022-04-03T10:34:08.000Z","categories_index":"程序设计","tags_index":"并查集","author_index":"shallow"},{"id":"d78199dbabc681e201328dc8f8002dc2","title":"share","content":"","slug":"share","date":"2022-01-22T09:06:40.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"\n\n\n\n\n\n提示\n注意了，这是个tip\n\n\n\n\n\n\n\n标题\n哈哈，自定义\n\n\n\n\n\n\n\n\n注意\n警告一次！\n\n\n点开看看\n你个傻逼\n\n","slug":"test","date":"2022-01-10T15:11:45.000Z","categories_index":"测试","tags_index":"开发者","author_index":"shallow"},{"id":"6181be25ee551197b04a134e589faeae","title":"年度总结","content":"再见，2021收获走过了一年，虽然一路上坎坎坷坷，但还是有很多快乐和值得纪念的事情😙\n\n我转专业成功了\n从机类转到计算机相关专业，虽然转专业之后的部分课程并不是我想象中的那么美好，但我还是觉得幸运，感谢当时果断做决定的自己。\n\n\n我参加了十四运会志愿者队伍\n对于一个普通人而言，能够参加这样的盛会是件非常高兴的事情，对我而言也确实如此。\n我记得西铁院下午的阳光，食堂门口的喷泉因此有了五彩的颜色。\n我记得体育馆凌晨的月光，我们度过了近20天不眠的夜晚。\n我记得机动队的四个人，一个下午分发了3万份的物资。\n我记得司机师傅的疲惫的笑容，和作为安全员的我送了一批又一批的演员前往排练。\n我当然还记得那时的火炬，仿佛要驱散一切阴霾似得，燃的热烈。正像大雨中的我们，虽然疲惫不堪却笑容满面，这种充满无私奉献，乐观主义的奋斗精神很难不让人热泪盈眶。\n\n\n我选择了很棒的技术社团和菁英班\n在RM的日子让我受益匪浅，我认识了很多优秀的学长和同龄人，和他们共同努力真的是件很棒的事，虽然自己在新知识的学习上愚笨而且懈怠，但也算是有所收获，希望2022年RM校队打破队史，再创佳绩！\n通过百度大数据人工智能菁英班的选拔是在我意料之外的事情，希望自己能对得起着来自不易的机会，在未来一周年的培养计划中向大佬们学习，不愧对这份幸运。\n\n\n\n遗憾又是一年风雨兼程，今年的我又有怎样的感叹呢🥲\n\n我还需要更成熟\n都说性格决定命运，以前我是不信的，现在倒有点相信了。由于我的没心没肺，错过了很多可能改编我人生轨迹的事情，在与人交往的过程中也有很多不当之处，希望未来的自己能够严于律己，凡事三思而后行。\n\n\n我还需要更勇敢\n还记得去年这个时候我在华山许愿，希望自己的2021年变得勇敢，能够万事胜意，。我也确实做到了一部分，可我还是觉得远远不够，对于一些毫无把握的事我也许可以再尝试尝试，万一就出现转机了呢，对于现在一无所有的我而言，如果再不够勇敢那就真的什么都不剩下了，希望未来一年不要错过一切我在意的东西。\n\n\n我还需要更自律\n过度沉迷手机，刷一些无意义的内容占用了我大量的休息时间，它们原本可以有更好的安排，但我没有这样做，也许这种事后诸葛亮的呻吟可能一点用处都没有，但我还是希望自己可以更加自律，合理安排自己的生活。\n\n\n\n你好，2022期望\n学业成绩和竞赛不留遗憾，戒骄戒躁，珍惜大学本科时光。\n生活不留遗憾，依然要投身志愿活动中，那是我一直坚持的。\n对自己不留遗憾，对于在意的事情要努力去争取。\n\n\n那么新年第一条愿望，就是祝看到这个博客的你2022得偿所愿，日日顺心🥰","slug":"my2021","date":"2021-12-31T13:12:12.000Z","categories_index":"总结","tags_index":"开发者","author_index":"shallow"},{"id":"b48181ff5fc549c282670b2e3976c524","title":"PTA数据结构08","content":"题目要求​        因为一棵二叉树的遍历可以用堆栈来模拟，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出\nInput Specification:6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\nOutput Specification:3 4 2 6 5 1\n解析：​        首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为\ntypedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;\n​        接下来考虑Push和Pop的对应操作该如何实现\nPush：对于一个结点优先访问其左子树，其次右子树\nPop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作\n完整代码#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s\n","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","categories_index":"题目集","tags_index":"PTA,树","author_index":"shallow"},{"id":"c64fb311e63f4c1eefb237f294f60a66","title":"PTA数据结构05","content":"题目要求给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出”YES”,否则”NO”\nInput Specification:第一行依次为M、N、K，后跟K行样例\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\nOutput Specification:YES\nNO\nNO\nYES\nNO\n解析由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止\n显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期\n示例代码#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;\n","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","categories_index":"题目集","tags_index":"PTA,线性结构","author_index":"shallow"},{"id":"1f2e6374a67016c059eddb723ab0efc5","title":"博客介绍","content":"这是一个怎样的博客？博客性质\n个人博客，分享生活感悟\n记录博客，分享学习心得\n\n你能在这里收获什么\n了解开发者的心路历程，与开发者共情（反正就是好朋友 😠）\n学习上获得帮助：本站主要是技术内容的分享\n\n如何使用本站？\n通过tag或category标签来检索内容\n合理设置关键字，在搜索框中进行检索\n\n还没想好\n未完待续\n未完待续\n未完待续\n\n","slug":"博客介绍","date":"2021-11-26T05:38:30.000Z","categories_index":"教程","tags_index":"开发者,入站必读","author_index":"shallow"}]