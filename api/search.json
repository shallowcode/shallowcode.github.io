[{"id":"e24161b022b99e01e5ff1a820d3ba3c0","title":"cf-785-div2","content":" C\n 题意：给出一个数n，n可以用若干回文数之和的形式表示出来，求有多少种方法来表示\n 方法：\n先枚举回文数\nbool check(int x)&#123;\n  int n&#x3D;0,xx&#x3D;x;\n  while(x)&#123;\n    n&#x3D;n*10+x%10;\n    x&#x2F;&#x3D;10;\n\t&#125;\n  if(x&#x3D;&#x3D;n) return 1;\n  else return 0;\n&#125;\nvector&lt;int&gt; mp;\nif(check(k))mp.oush)back(k);\n然后经典dp,即dp(i)(j)dp(i)(j)dp(i)(j)代表用前j个数拼成i的方案有多少种\ndp[i][j]={1dp[i][j−1]dp[i][j−1]+dp[i−mp[j]][j]dp[i][j]={\\begin{cases}\n \\qquad1\\\\ \n dp[i][j-1]\\\\ \n dp[i][j-1]+dp[i-mp[j]][j]\n\\end{cases}}\ndp[i][j]=⎩⎪⎨⎪⎧​1dp[i][j−1]dp[i][j−1]+dp[i−mp[j]][j]​\n D\n 题意：已知给出一个等差数列的首项，公差，项数可以知道其全部信息，给出两个等差数列B，C的信息，已知C是B与另一等差数列A的共同元素组成的等差数列，求A可能的数目，其中数目为0，无穷大时要特判\n 方法：\n若不满足以下条件，则A的数目为0\n\nC被B完全覆盖\nC的公差是B的公差的倍数\nC的某一项要和B的第一项相同\n\n在A的数目不为0的前提下，若满足以下条件之一，则A的数目为无穷多个\n\nB的第一项大于C的第一项的前一项\nB的最后一项小于C的最后一项的后一项\n\n在满足A的数目不为无穷多个时，发现A的第一项必须要大于C的第一项的前一项，最后一项同理，同时仍要满足\nlcm(p,q)=rlcm(p,q)=rlcm(p,q)=r以及(c−a)modp=0(c-a)mod p=0(c−a)modp=0,枚举r的所有因数，则最终结果为ans=∑lcm(p,q)=r(rp)2ans=\\sum_{lcm(p,q)=r}(\\frac{r}{p})^2ans=∑lcm(p,q)=r​(pr​)2\n","slug":"cf-785-div2","date":"2022-05-02T01:26:10.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"1f95e29524cb1fc8f16f7dbdf365181a","title":"二叉堆","content":"&#x2F;&#x2F;手动实现\nvoid shift(int i)&#123;\n    while(1)&#123;\n        int l&#x3D;2*i;\n        if(l&lt;&#x3D;len-1&amp;&amp;a[l]&gt;a[l+1])l++;\n        if(l&gt;len||a[i]&lt;a[l]) break;\n        swap(a[i],a[l]);\n        i&#x3D;l;\n    &#125;\n&#125;\na[0]&#x3D;-1;&#x2F;&#x2F;堆的最顶层是最小的或者最大的\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;\n            cin&gt;&gt;x;a[++len]&#x3D;x;\n            int i&#x3D;len;\n            while(a[i]&lt;a[i&#x2F;2])&#123;\n                swap(a[i],a[i&#x2F;2]);\n                i&#x2F;&#x3D;2;\n            &#125;\n        &#125;&#x2F;&#x2F;新加入节点，放到最后一个，依次和父节点比较\n        else if(op&#x3D;&#x3D;2)&#123;\n            cout&lt;&lt;a[1]&lt;&lt;endl;\n        &#125;\n        else&#123;\n            swap(a[1],a[len--]);\n            for (int i&#x3D;len&#x2F;2;i&gt;&#x3D;1;--i)&#123;\n                shift(i);\n            &#125;\n        &#125;&#x2F;&#x2F;对于删除节点，将第一个元素和最后一个元素交换，然后从该节点的父节点一直到第一个节点依次向下更新\n    &#125;\n&#x2F;&#x2F;实现堆的简单方法-优先队列\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint n,op,x;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;1&quot;,&quot;r&quot;,stdin);freopen(&quot;2&quot;,&quot;w&quot;,stdout);\n    ios::sync_with_stdio(false);cin.tie(0);\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;x;q.push(x);&#125;\n        else if(op&#x3D;&#x3D;2) cout&lt;&lt;q.top()&lt;&lt;endl;\n        else q.pop();\n    &#125;\n&#125;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;小根堆\npriority_queue&lt;int&gt;大根堆\nq.top()&#x2F;&#x2F;取得堆顶元素，并不会弹出\nq.pop()&#x2F;&#x2F;弹出堆顶元素\nq.push()&#x2F;&#x2F;往堆里面插入一个元素\nq.empty()&#x2F;&#x2F;查询堆是否为空，为空则返回1否则返回0\nq.size()&#x2F;&#x2F;查询堆内元素数量\n","slug":"二叉堆","date":"2022-04-27T06:23:23.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"fa4d4536e5d7115952b0289a4a257f8c","title":"cf-783-div2","content":" C\n 题意：给出长度为的序列,长度为的序列中初始值全是,每次操作可以让加上或者减去,问最少操作多少次才能使变成一个严格单调递增的序列.\n 方法：贪心的考虑，最终数组一定会有0存在，枚举0的位置，依次计算达到严格单调递增所需要移动的次数\nint main()&#123;\n    n&#x3D;read();\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i]&#x3D;read();\n    &#125;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        ll pre&#x3D;0,cnt&#x3D;0;\n        for (int j&#x3D;i+1;j&lt;&#x3D;n;++j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        pre&#x3D;0;\n        for (int j&#x3D;i-1;j&gt;&#x3D;1;--j)&#123;\n            pre+&#x3D;a[j]-pre%a[j];\n            cnt+&#x3D;pre&#x2F;a[j];\n        &#125;\n        cnt_min&#x3D;min(cnt_min,cnt);\n    &#125;\n    printf(&quot;%lld&quot;,cnt_min);\n&#125;\npre+=a[j]-pre%a[j]满足大于pre且是a[j]的倍数的最小值\n D\n 题意：有一个长度为n的序列a，可以将其切割成连续的若干子列，每部分子列得分如下\n\n如果子列和大于0，得分为子列的长度\n如果子列和等于0，得分为0\n如果子列和小于0，得分为子列的长度*-1\n\n 分析：\n","slug":"cf-783-div2","date":"2022-04-20T03:13:31.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"75693a8c6f85806ac837bdc72f35a1c0","title":"树状数组2","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500005\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int l,int r,ll k)&#123;\n    while(l&lt;&#x3D;n)&#123;\n        ans[l]+&#x3D;k;\n        l+&#x3D;l&amp;-l;\n    &#125;\n    r++;\n    while(r&lt;&#x3D;n)&#123;\n        ans[r]-&#x3D;k;\n        r+&#x3D;r&amp;-r;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,i,temp);\n    &#125;\n&#125;\n\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            x&#x3D;read();y&#x3D;read();ret&#x3D;read();\n            add(x,y,ret);\n        &#125;\n        else&#123;\n            x&#x3D;read();\n            printf(&quot;%lld\\n&quot;,sum(x));\n        &#125;\n    &#125;\n&#125;\n","slug":"树状数组2","date":"2022-04-19T08:42:09.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"a9af62bfd9db986968c6d2172b939d09","title":"树状数组1","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll long long\n#define MAX 500001\nusing namespace std;\nll read()&#123;\n    char c&#x3D;getchar();ll x&#x3D;0;int f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar()) if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nll n,m,x,y,ret;\nll ans[MAX&lt;&lt;1];\nvoid add(int x,ll k)&#123;\n    while(x&lt;&#x3D;n)&#123;\n        ans[x]+&#x3D;k;\n        x+&#x3D;x&amp;-x;\n    &#125;\n&#125;\nvoid init()&#123;\n    ll temp;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        temp&#x3D;read();\n        add(i,temp);\n    &#125;\n&#125;\nll sum(int x)&#123;\n    ll temp&#x3D;0;\n    while(x)&#123;\n        temp+&#x3D;ans[x];\n        x-&#x3D;x&amp;-x;\n    &#125;\n    return temp;\n&#125;\n\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    while(m--)&#123;\n        ret&#x3D;read();x&#x3D;read();y&#x3D;read();\n        if(ret&#x3D;&#x3D;1)&#123;\n            add(x,y);\n        &#125;\n        else&#123;\n            printf(&quot;%lld\\n&quot;,sum(y)-sum(x-1));\n        &#125;\n    &#125;\n&#125;\n\n","slug":"树状数组1","date":"2022-04-19T06:36:42.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"001dbd05b69938b44aa0e24828eb90f6","title":"线段树2","content":"void init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i]&#x3D;read();\n    &#125;\n&#125;&#x2F;&#x2F;初始化\ninline ll ls(long p) &#123;return p&lt;&lt;1;&#125;\ninline ll rs(long p) &#123;return p&lt;&lt;1|1;&#125;\n\ninline void pull_up(ll p)&#123;\n    ans[p]&#x3D;(ans[ls(p)]+ans[rs(p)])%MOD;\n&#125;&#x2F;&#x2F;回溯区间维护的值（这里是区间和取模）\n\ninline void f(ll p,ll l,ll r,ll k1,ll k2)&#123;\n    tag1[p]&#x3D;(tag1[p]*k2+k1)%MOD;&#x2F;&#x2F;加法标记更改，乘法会影响加法标记\n    tag2[p]&#x3D;(tag2[p]*k2)%MOD;&#x2F;&#x2F;乘法标记更改\n    ans[p]&#x3D;(ans[p]*k2+k1*(r-l+1))%MOD;&#x2F;&#x2F;在线修改区间维护的值（这里是区间和取模）为维持精度，先乘法再加法\n&#125;\n\ninline void push_down(ll p,ll l,ll r)&#123;\n    ll mid&#x3D;(l+r)&gt;&gt;1;\n    f(ls(p),l,mid,tag1[p],tag2[p]);\n    f(rs(p),mid+1,r,tag1[p],tag2[p]);\n    tag1[p]&#x3D;0;tag2[p]&#x3D;1;&#x2F;&#x2F;清除父节点标记\n&#125;\n&#x2F;&#x2F;父节点依据lazytag对子节点传递信息：我的子节点要有怎样的改变，同时我的子节点所管理的区间应该是怎样的\nvoid build(ll p,ll l,ll r)&#123;\n    tag1[p]&#x3D;0;tag2[p]&#x3D;1;\n    if(l&#x3D;&#x3D;r)&#123;\n        ans[p]&#x3D;a[l];\n        return;\n    &#125;\n    ll mid&#x3D;(l+r)&gt;&gt;1;\n    &#x2F;&#x2F;递归建树\n    build(ls(p),l,mid);\n    build(rs(p),mid+1,r);\n    pull_up(p);\n    &#x2F;&#x2F;回溯\n&#125;\nvoid add(ll nl,ll rl,ll p,ll l,ll r,ll k)&#123;\n    if(nl&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;rl)&#123;\n        &#x2F;&#x2F;在目标区间直接在线更新维护的值和lazytag\n        tag1[p]&#x3D;(tag1[p]+k)%MOD;\n        ans[p]&#x3D;(ans[p]+k*(r-l+1))%MOD;\n        return;\n    &#125;\n    push_down(p,l,r);&#x2F;&#x2F;向下传递lazytag\n    ll mid&#x3D;(l+r)&gt;&gt;1;\n    if(nl&lt;&#x3D;mid) add(nl,rl,ls(p),l,mid,k);\n    if(rl&gt;mid) add(nl,rl,rs(p),mid+1,r,k);\n    pull_up(p);&#x2F;&#x2F;回溯\n&#125;\nvoid mul(ll nl,ll rl,ll p,ll l,ll r,ll k)&#123;\n    if(nl&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;rl)&#123;\n        &#x2F;&#x2F;乘法lazytag会对加法lazytag产生影响\n        tag1[p]&#x3D;(tag1[p]*k)%MOD;\n        tag2[p]&#x3D;(tag2[p]*k)%MOD;\n        ans[p]&#x3D;(ans[p]*k)%MOD;\n        return;\n    &#125;\n    push_down(p,l,r);\n    ll mid&#x3D;(l+r)&gt;&gt;1;\n    if(nl&lt;&#x3D;mid) mul(nl,rl,ls(p),l,mid,k);\n    if(rl&gt;mid) mul(nl,rl,rs(p),mid+1,r,k);\n    pull_up(p);\n&#125;\nll index(ll nl,ll rl,ll p,ll l,ll r)&#123;\n    if(nl&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;rl) return ans[p]%MOD;\n    long sum&#x3D;0;\n    push_down(p,l,r);\n    ll mid&#x3D;(l+r)&gt;&gt;1;\n    if(nl&lt;&#x3D;mid) sum&#x3D;(sum+index(nl,rl,ls(p),l,mid))%MOD;\n    if(rl&gt;mid) sum&#x3D;(sum+index(nl,rl,rs(p),mid+1,r))%MOD;\n    return sum;\n&#125;\n","slug":"线段树2","date":"2022-04-18T15:16:53.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"da049d4802afb8f23eb9317447dbf0d1","title":"线段树1","content":"#include&lt;bits&#x2F;stdc++.h&gt;\n#define MAXN 100001\n&#x2F;&#x2F;线段数模版\n&#x2F;&#x2F;查询：区间和\n&#x2F;&#x2F;更改：区间每个数加k\nusing namespace std;\nlong n,m;\nlong a[MAXN],ans[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2];&#x2F;&#x2F;原始数据，节点（区间）数据，标记（子节点服从父节点的标记）\ninline long read()&#123;\n    char c&#x3D;getchar();long x&#x3D;0,f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar())if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;&#x2F;&#x2F;快读\ninline long ls(long p) &#123;return p&lt;&lt;1;&#125;&#x2F;&#x2F;查询\ninline long rs(long p) &#123;return p&lt;&lt;1|1;&#125;\nvoid init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i]&#x3D;read();\n    &#125;\n&#125;&#x2F;&#x2F;初始化\ninline void pull_up(long p)&#123;\n    ans[p]&#x3D;ans[ls(p)]+ans[rs(p)];\n&#125;&#x2F;&#x2F;子节点与父节点建立逻辑\nvoid build(long p,long l,long r)&#123;\n    if(l&#x3D;&#x3D;r)&#123;\n        ans[p]&#x3D;a[l];\n        return ;\n    &#125;\n    long mid&#x3D;(l+r)&gt;&gt;1;\n    build(ls(p),l,mid);\n    build(rs(p),mid+1,r);\n    pull_up(p);&#x2F;&#x2F;向上传递\n&#125;\ninline void f(long p,long l,long r,long k)&#123;\n    ans[p]+&#x3D;k*(r-l+1);&#x2F;&#x2F;更新新区间的总和\n    tag[p]+&#x3D;k;&#x2F;&#x2F;更新新节点的区间加值\n&#125;&#x2F;&#x2F;子节点接受父节点的信息\ninline void push_down(long p,long l,long r)&#123;\n    long mid&#x3D;(l+r)&gt;&gt;1;\n    f(ls(p),l,mid,tag[p]);&#x2F;&#x2F;维护左节点\n    f(rs(p),mid+1,r,tag[p]);&#x2F;&#x2F;维护右节点\n    tag[p]&#x3D;0;\n&#125;\nvoid upgrade(long nl,long nr,long l,long r,long p,long k)&#123;\n    if(nl&lt;&#x3D;l&amp;&amp;nr&gt;&#x3D;r)&#123;\n        ans[p]+&#x3D;k*(r-l+1);\n        tag[p]+&#x3D;k;&#x2F;&#x2F;如果不往下更新了要留一个标记如果要查下面再更新\n        return;\n    &#125;\n    push_down(p,l,r);&#x2F;&#x2F;如果当前区间不被查询区间包含，直接向下传递\n    long mid&#x3D;(l+r)&gt;&gt;1;\n    if(nl&lt;&#x3D;mid) upgrade(nl,nr,l,mid,ls(p),k);\n    if(mid&lt;nr) upgrade(nl,nr,mid+1,r,rs(p),k);\n    pull_up(p);\n&#125;&#x2F;&#x2F;[nl,nr]为查询区间,l,r为当前p节点维护的区间,k为该区间每个值加多少\nlong index(long x,long y,long l,long r,long p)&#123;\n    if(x&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;y) return ans[p];\n    long result&#x3D;0;\n    push_down(p,l,r);\n    long mid&#x3D;(l+r)&gt;&gt;1;\n    if(x&lt;&#x3D;mid) result+&#x3D;index(x,y,l,mid,ls(p));\n    if(mid&lt;y) result+&#x3D;index(x,y,mid+1,r,rs(p));\n    return result;\n&#125;\nint main()&#123;\n    n&#x3D;read();m&#x3D;read();\n    init();\n    build(1,1,n);\n    while(m--)&#123;\n        int ret&#x3D;read();\n        long x,y;\n        if(ret&#x3D;&#x3D;1)&#123;\n            x&#x3D;read();y&#x3D;read();ret&#x3D;read();\n            upgrade(x,y,1,n,1,ret);\n        &#125;\n        else&#123;\n            x&#x3D;read();y&#x3D;read();\n            printf(&quot;%ld\\n&quot;,index(x,y,1,n,1));\n        &#125;\n    &#125;\n&#125;\n","slug":"线段树1","date":"2022-04-17T13:15:53.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"f6c19d68f103e4d846ec55d23a2ae394","title":"st表","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,l,r;\nint a[max_n][max_n的2进制最高位];\ninline int read()&#123;\n    char c&#x3D;getchar();int x&#x3D;0,f&#x3D;1;\n    for (;!isdigit(c);c&#x3D;getchar())if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;\n    for (;isdigit(c);c&#x3D;getchar()) x&#x3D;x*10+c-48;\n    return x*f;\n&#125;\nint main()&#123;\n    n&#x3D;read(),m&#x3D;read();\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        a[i][0]&#x3D;read();\n    &#125;\n    for (int j&#x3D;1;j&lt;&#x3D;18;++j)&#123;\n        for (int i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;++i)&#123;\n            a[i][j]&#x3D;max(a[i][j-1],a[i+(1&lt;&lt;(j-1))][j-1]);\n        &#125;\n    &#125;\n  &#x2F;&#x2F;a[i][j]:第i个元素后j个中最大值\n    while(m--)&#123;\n        l&#x3D;read(),r&#x3D;read();\n        int k&#x3D;log2(r-l+1);\n        printf(&quot;%d\\n&quot;,max(a[l][k],a[r-(1&lt;&lt;k)+1][k]));\n    &#125;\n&#125;\n","slug":"st表","date":"2022-04-16T15:49:50.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"035226029ada45b479a35ef3c152f51f","title":"头文件","content":"#include &lt;algorithm&gt;\n#include &lt;cctype&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;iomanip&gt;       \n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n","slug":"头文件","date":"2022-04-16T14:10:35.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"a8700b1bec2379b19ad66ea321a2af93","title":"线性筛模版","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,q,k,cnt;\nbool isprime[100000001];\nint prime[100000001];\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;q;\n    for (int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;\n        if(!isprime[i])&#123;\n            prime[++cnt]&#x3D;i;\n        &#125;\n        for (int j&#x3D;1;j&lt;&#x3D;cnt&amp;&amp;prime[j]*i&lt;&#x3D;n;++j)&#123;\n            isprime[prime[j]*i]&#x3D;1;\n            if(i%prime[j]&#x3D;&#x3D;0) break;\n        &#125;\n    &#125;\n    while(q--)&#123;\n        cin&gt;&gt;k;\n        cout&lt;&lt;prime[k]&lt;&lt;endl;\n    &#125;\n&#125;\n","slug":"线性筛模版","date":"2022-04-08T05:46:50.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"ca78808e8f9986ff3df37d5abc438425","title":"组合数","content":"int c[max_n][max_n];\nfor (int i&#x3D;0;i&lt;&#x3D;max_n;++i)&#123;\n\tfor (int j&#x3D;0;j&lt;&#x3D;i;++j)&#123;\n    \tif(i&#x3D;&#x3D;j||j&#x3D;&#x3D;0) c[i][j]&#x3D;1;\n    \telse c[i][j]&#x3D;c[i-1][j-1]+c[i-1][j];\n\t&#125;\n&#125;\n&#x2F;&#x2F;求组合数必要时取模\n","slug":"组合数","date":"2022-04-07T15:22:59.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"3a5edbaf2fab1786cda1ddc2eee70e29","title":"进制转换","content":"#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,ans;\nvoid otp(int x)&#123;\n    if(!x) return;\n    otp(x&#x2F;m);\n    char s&#x3D;x%m&gt;&#x3D;10?55+x%m:48+x%m;\n    putchar(s);\n&#125;\nint exe(char c)&#123;\n    return c&gt;&#x3D;65?c-55:c-48;\n&#125;\nint read()&#123;\n    int x&#x3D;0;\n    char c&#x3D;getchar();\n    for (;c&lt;48||c&gt;57&amp;&amp;c&lt;65||c&gt;70;c&#x3D;getchar())&#123;&#125;\n    for (;c&gt;&#x3D;48&amp;&amp;c&lt;&#x3D;57||c&gt;&#x3D;65&amp;&amp;c&lt;&#x3D;70;c&#x3D;getchar())&#123; x&#x3D;x*n+exe(c);&#125;\n    return x;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    ans&#x3D;read();\n    cin&gt;&gt;m;\n    otp(ans);\n&#125;\n","slug":"进制转换","date":"2022-04-06T05:30:25.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"5757d25a41334dab48eea89b5201dea3","title":"算法讲解","content":" 有向图强连通分量的Tarjan算法\nhttps://byvoid.com/zhs/blog/scc-tarjan/\n","slug":"算法讲解","date":"2022-04-05T07:34:09.000Z","categories_index":"教程","tags_index":"算法","author_index":"shallow"},{"id":"be4fadc0757b3a2eeaefd20302787665","title":"集合","content":" 题目要求\nCaima 给你了所有**[a,b]**范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 p的公共质因数，那么把它们所在的集合合并。重复如上操作，直到没有可以合并的集合为止。现在 Caima 想知道，最后有多少个集合。\n 输入格式\n一行三个整数,a,b,p\n 输出格式\n一个数，最终的集合数\n 源代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint a,b,p;\nint fa[100001];\nbool prime[100001];\nint find(int x)&#123;\n    return fa[x]&#x3D;&#x3D;x?x:fa[x]&#x3D;find(fa[x]);\n&#125;\nint main()&#123;\n    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    int ans&#x3D;b-a+1;\n    for (int i&#x3D;a;i&lt;&#x3D;b;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n    for (int i&#x3D;2;i&lt;&#x3D;b;++i)&#123;\n        if(!prime[i])&#123;\n            if(i&gt;&#x3D;p)&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                    if(j-i&gt;&#x3D;a&amp;&amp;find(j-i)!&#x3D;find(j))&#123;\n                        ans--;\n                        fa[find(j)]&#x3D;find(j-i);\n                    &#125;\n                &#125;\n            &#125;\n            else&#123;\n                for (int j&#x3D;2*i;j&lt;&#x3D;b;j+&#x3D;i)&#123;\n                    prime[j]&#x3D;true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;ans;\n&#125;\n","slug":"集合","date":"2022-04-04T04:58:47.000Z","categories_index":"程序设计","tags_index":"并查集,埃尔筛法","author_index":"shallow"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":" 并查集\n并查集是一种用来管理元素分组情况的数据结构，并查集可以高效地进行如下操作：\n\n查询元素a和b是否属于同一组\n合并元素a和b所在的组\n\nint n;&#x2F;&#x2F;一共有n个数据\n\nint fa[max_n+1];&#x2F;&#x2F;保存每个结点的父亲节点，其中根的父结点是自己\nint h[max_n+1];&#x2F;&#x2F;保存树的高度，避免退化影响复杂度\n\nvoid init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n&#125;&#x2F;&#x2F;初始化每个节点的父节点是自己\n\nint find(int x)&#123;\n    if(fa[x]&#x3D;&#x3D;x) return x;\n    else return fa[x]&#x3D;find(fa[x]);\n&#125;&#x2F;&#x2F;找一个节点的根节点，顺便把自己直接连到根节点上\n\nvoid unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    if(x!&#x3D;y)&#123;\n        if(h[x]&lt;h[y]) fa[x]&#x3D;y;\n        else fa[y]&#x3D;x;\n        if(h[x]&#x3D;&#x3D;h[y]) h[x]++;\n    &#125;\n&#125;&#x2F;&#x2F;高度小的树作为高度大的树的子节点，树的高度在两树相等的时候更新\n","slug":"并查集","date":"2022-04-03T10:34:08.000Z","categories_index":"程序设计","tags_index":"并查集","author_index":"shallow"},{"id":"d78199dbabc681e201328dc8f8002dc2","title":"share","content":"","slug":"share","date":"2022-01-22T09:06:40.000Z","categories_index":"","tags_index":"","author_index":"shallow"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":":::tip\n注意了，这是个tip\n:::\n:::tip 标题\n哈哈，自定义\n:::\n:::warning\n警告一次！\n:::\n:::details 点开看看\n你个傻逼\n:::\n","slug":"test","date":"2022-01-10T15:11:45.000Z","categories_index":"测试","tags_index":"开发者","author_index":"shallow"},{"id":"6181be25ee551197b04a134e589faeae","title":"年度总结","content":" 再见，2021\n 收获\n走过了一年，虽然一路上坎坎坷坷，但还是有很多快乐和值得纪念的事情😙\n\n我转专业成功了\n\n从机类转到计算机相关专业，虽然转专业之后的部分课程并不是我想象中的那么美好，但我还是觉得幸运，感谢当时果断做决定的自己。\n\n\n我参加了十四运会志愿者队伍\n\n对于一个普通人而言，能够参加这样的盛会是件非常高兴的事情，对我而言也确实如此。\n我记得西铁院下午的阳光，食堂门口的喷泉因此有了五彩的颜色。\n我记得体育馆凌晨的月光，我们度过了近20天不眠的夜晚。\n我记得机动队的四个人，一个下午分发了3万份的物资。\n我记得司机师傅的疲惫的笑容，和作为安全员的我送了一批又一批的演员前往排练。\n我当然还记得那时的火炬，仿佛要驱散一切阴霾似得，燃的热烈。正像大雨中的我们，虽然疲惫不堪却笑容满面，这种充满无私奉献，乐观主义的奋斗精神很难不让人热泪盈眶。\n\n\n我选择了很棒的技术社团和菁英班\n\n在RM的日子让我受益匪浅，我认识了很多优秀的学长和同龄人，和他们共同努力真的是件很棒的事，虽然自己在新知识的学习上愚笨而且懈怠，但也算是有所收获，希望2022年RM校队打破队史，再创佳绩！\n通过百度大数据人工智能菁英班的选拔是在我意料之外的事情，希望自己能对得起着来自不易的机会，在未来一周年的培养计划中向大佬们学习，不愧对这份幸运。\n\n\n\n 遗憾\n又是一年风雨兼程，今年的我又有怎样的感叹呢🥲\n\n我还需要更成熟\n\n都说性格决定命运，以前我是不信的，现在倒有点相信了。由于我的没心没肺，错过了很多可能改编我人生轨迹的事情，在与人交往的过程中也有很多不当之处，希望未来的自己能够严于律己，凡事三思而后行。\n\n\n我还需要更勇敢\n\n还记得去年这个时候我在华山许愿，希望自己的2021年变得勇敢，能够万事胜意，。我也确实做到了一部分，可我还是觉得远远不够，对于一些毫无把握的事我也许可以再尝试尝试，万一就出现转机了呢，对于现在一无所有的我而言，如果再不够勇敢那就真的什么都不剩下了，希望未来一年不要错过一切我在意的东西。\n\n\n我还需要更自律\n\n过度沉迷手机，刷一些无意义的内容占用了我大量的休息时间，它们原本可以有更好的安排，但我没有这样做，也许这种事后诸葛亮的呻吟可能一点用处都没有，但我还是希望自己可以更加自律，合理安排自己的生活。\n\n\n\n 你好，2022\n 期望\n\n学业成绩和竞赛不留遗憾，戒骄戒躁，珍惜大学本科时光。\n生活不留遗憾，依然要投身志愿活动中，那是我一直坚持的。\n对自己不留遗憾，对于在意的事情要努力去争取。\n\n\n 那么新年第一条愿望，就是祝看到这个博客的你2022得偿所愿，日日顺心🥰\n","slug":"my2021","date":"2021-12-31T13:12:12.000Z","categories_index":"总结","tags_index":"开发者","author_index":"shallow"},{"id":"b48181ff5fc549c282670b2e3976c524","title":"PTA数据结构08","content":" 题目要求\n​\t\t因为一棵二叉树的遍历可以用堆栈来模拟，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出\n Input Specification:\n6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\n Output Specification:\n3 4 2 6 5 1\n 解析：\n​\t\t首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为\ntypedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;\n​\t\t接下来考虑Push和Pop的对应操作该如何实现\nPush：对于一个结点优先访问其左子树，其次右子树\nPop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作\n 完整代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s\n","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","categories_index":"题目集","tags_index":"PTA,树","author_index":"shallow"},{"id":"c64fb311e63f4c1eefb237f294f60a66","title":"PTA数据结构05","content":" 题目要求\n给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出&quot;YES&quot;,否则&quot;NO&quot;\n Input Specification:\n第一行依次为M、N、K，后跟K行样例\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n Output Specification:\nYES\nNO\nNO\nYES\nNO\n 解析\n由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止\n显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期\n 示例代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;\n","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","categories_index":"题目集","tags_index":"PTA,线性结构","author_index":"shallow"},{"id":"1f2e6374a67016c059eddb723ab0efc5","title":"博客介绍","content":" 这是一个怎样的博客？\n 博客性质\n\n个人博客，分享生活感悟\n记录博客，分享学习心得\n\n 你能在这里收获什么\n\n了解开发者的心路历程，与开发者共情（反正就是好朋友 😠）\n学习上获得帮助：本站主要是技术内容的分享\n\n 如何使用本站？\n\n通过tag或category标签来检索内容\n合理设置关键字，在搜索框中进行检索\n\n 还没想好\n\n未完待续\n未完待续\n未完待续\n\n","slug":"博客介绍","date":"2021-11-26T05:38:30.000Z","categories_index":"教程","tags_index":"开发者,入站必读","author_index":"shallow"}]