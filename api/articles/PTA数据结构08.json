{"title":"PTA数据结构08","uid":"b48181ff5fc549c282670b2e3976c524","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","updated":"2021-12-01T04:54:54.340Z","comments":true,"path":"api/articles/PTA数据结构08.json","keywords":null,"cover":null,"content":"<h2 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h2><p>​        因为一棵二叉树的遍历可以用堆栈来表示，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出</p>\n<h3 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h3><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop</code></pre>\n<h3 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h3><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">3 4 2 6 5 1</code></pre>\n<h2 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h2><p>​        首先考虑构建二叉树的问题，我将结点的元素设置为5个，分别为</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct node&#123;\n    int data;&#x2F;&#x2F;本身元素\n    int ret;&#x2F;&#x2F;初始化为1.判定元素是否在栈中\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;&#x2F;&#x2F;建立父结点，在回溯时更方便\n&#125;node;\ntypedef node* tree;</code></pre>\n<p>​        接下来考虑Push和Pop的对应操作该如何实现</p>\n<p>Push：对于一个结点优先访问其左子树，其次右子树</p>\n<p>Pop：不断回溯，直到回溯到的结点没有被Pop过，执行Pop操作</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef struct node&#123;\n    int data;\n    int ret;\n    struct node* lchild;\n    struct node* rchild;\n    struct node* parent;\n&#125;node;\ntypedef node* tree;\n\nvoid posttravel(tree head)&#123;\n    if(!head)&#123;\n    &#125;\n    else&#123;\n        posttravel(head-&gt;lchild);\n        posttravel(head-&gt;rchild);\n        cout &lt;&lt; head-&gt;data;\n        if(head-&gt;parent)&#123;\n            cout &lt;&lt;&quot; &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    int n;\n    string sign;\n    tree head&#x3D;NULL;\n    cin &gt;&gt; n;\n    for (int i&#x3D;0;i&lt;2*n;++i)&#123;\n        cin &gt;&gt; sign;\n        if (sign&#x3D;&#x3D;&quot;Push&quot;)&#123;\n            if(!head)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else if(!head-&gt;lchild)&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;lchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n            else&#123;\n                tree temp&#x3D;(tree)malloc(sizeof(node));\n                temp-&gt;parent&#x3D;head;\n                head-&gt;rchild&#x3D;temp;\n                temp-&gt;lchild&#x3D;NULL;\n                temp-&gt;rchild&#x3D;NULL;\n                cin &gt;&gt; temp-&gt;data;\n                temp-&gt;ret&#x3D;1;\n                head&#x3D;temp;\n            &#125;\n        &#125;\n        else&#123;\n            while(!head-&gt;ret)&#123;\n                head&#x3D;head-&gt;parent;\n            &#125;\n            head-&gt;ret&#x3D;0;\n        &#125;\n    &#125;\n    while(head-&gt;parent)&#123;\n        head&#x3D;head-&gt;parent;\n    &#125;\n    posttravel(head);\n&#125;s</code></pre>\n","text":"题目要求​ 因为一棵二叉树的遍历可以用堆栈来表示，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出 Input Specification:6 Push 1 Push 2 Push 3 Pop Pop Push 4 Pop Pop Push 5 Pu...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"题目集","slug":"题目集","count":2,"path":"api/categories/题目集.json"}],"tags":[{"name":"PTA","slug":"PTA","count":2,"path":"api/tags/PTA.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">题目要求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Input-Specification\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Output-Specification\"><span class=\"toc-text\">Output Specification:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">解析：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"achievement","uid":"5c3a2a49db83eb8792b0f274b908293e","slug":"achievement","date":"2021-12-16T15:27:05.000Z","updated":"2021-12-18T02:05:39.631Z","comments":true,"path":"api/articles/achievement.json","keywords":null,"cover":null,"text":"2021.12.15入选百度人工智能大数据菁英班😇 2021.11.28极限飞盘新秀赛取得了倒数第二的好成绩😋 ","link":"","photos":[],"count_time":{"symbolsCount":58,"symbolsTime":"1 mins."},"categories":[{"name":"回忆","slug":"回忆","count":2,"path":"api/categories/回忆.json"}],"tags":[{"name":"开发者","slug":"开发者","count":3,"path":"api/tags/开发者.json"}],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"PTA数据结构05","uid":"c64fb311e63f4c1eefb237f294f60a66","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","updated":"2021-12-01T04:35:29.335Z","comments":true,"path":"api/articles/PTA数据结构05.json","keywords":null,"cover":null,"text":"题目要求给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出”YES”,否则”NO” Input Specification:第一行依次为M、N、K，后跟K行样例 5 7 5 1 2 3 4 5 6 7 3 2 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"题目集","slug":"题目集","count":2,"path":"api/categories/题目集.json"}],"tags":[{"name":"PTA","slug":"PTA","count":2,"path":"api/tags/PTA.json"},{"name":"线性结构","slug":"线性结构","count":1,"path":"api/tags/线性结构.json"}],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}