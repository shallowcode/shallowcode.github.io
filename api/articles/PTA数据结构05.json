{"title":"PTA数据结构05","uid":"c64fb311e63f4c1eefb237f294f60a66","slug":"PTA数据结构05","date":"2021-11-26T16:27:54.000Z","updated":"2021-12-01T04:35:29.335Z","comments":true,"path":"api/articles/PTA数据结构05.json","keywords":null,"cover":null,"content":"<h2 id=\"题目要求\"><a class=\"markdownIt-Anchor\" href=\"#题目要求\"></a> 题目要求</h2>\n<p>给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出&quot;YES&quot;,否则&quot;NO&quot;</p>\n<h3 id=\"input-specification\"><a class=\"markdownIt-Anchor\" href=\"#input-specification\"></a> Input Specification:</h3>\n<p>第一行依次为M、N、K，后跟K行样例</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2</code></pre>\n<h3 id=\"output-specification\"><a class=\"markdownIt-Anchor\" href=\"#output-specification\"></a> Output Specification:</h3>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">YES\nNO\nNO\nYES\nNO</code></pre>\n<h2 id=\"解析\"><a class=\"markdownIt-Anchor\" href=\"#解析\"></a> 解析</h2>\n<p>由于入栈顺序是一定且递增的，所以对每个出栈的元素而言，必有比其小的元素都已入栈（包括自己），故进行顺序入栈操作并保存最大入栈值，直到假定出栈元素不大于栈顶元素或栈满为止</p>\n<p>显然若栈顶元素大于出栈元素则说明在之前某元素入栈时已经压入了比假定出栈元素更大的值，若小于则说明栈的大小不够提前终止，故此时假定出栈元素不可能出栈，若相等则成功出栈，将其移出栈，进入下个判定周期</p>\n<h2 id=\"示例代码\"><a class=\"markdownIt-Anchor\" href=\"#示例代码\"></a> 示例代码</h2>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint M,N,K;\nbool check(vector&lt;int&gt; lst)&#123;\n    int i&#x3D;0;&#x2F;&#x2F;遍历出栈队列\n    int num&#x3D;0;&#x2F;&#x2F;已经压入的最大值\n    stack&lt;int&gt; a;\n    a.push(0);\n    while(i&lt;N)&#123;\n        while(lst[i]&gt;a.top()&amp;&amp;a.size()&lt;&#x3D;M)&#123;\n            a.push(++num);\n        &#125;\n        if(lst[i++]!&#x3D;a.top())&#123;\n            return false;\n        &#125;\n        else&#123;\n            a.pop();\n        &#125;\n    &#125;\n    return true;\n&#125;\nint main()&#123;\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    vector&lt;int&gt; temp;\n    for (int i&#x3D;0;i&lt;K;++i)&#123;\n        for (int j&#x3D;0;j&lt;N;++j)&#123;\n            int a;\n            cin &gt;&gt; a;\n            temp.push_back(a);\n        &#125;\n        if(check(temp))&#123;\n            cout &lt;&lt; &quot;YES&quot;;\n        &#125;\n        else&#123;\n            cout &lt;&lt; &quot;NO&quot;;\n        &#125;\n        if(i!&#x3D;K-1)&#123;\n            cout &lt;&lt; endl;\n        &#125;\n        temp.clear();\n    &#125;\n&#125;</code></pre>\n","text":" 题目要求 给定一个最大能储存M个元素的栈，以1～N的顺序入栈，并同时随机出栈，编写程序对给出的K个拟定的出栈队列进行判定，存在输出&quot;YES&quot;,否则&quot;NO&quot; Input Specification: 第一行依次为M、N、K，后跟K行样例 5...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"题目集","slug":"题目集","count":2,"path":"api/categories/题目集.json"}],"tags":[{"name":"PTA","slug":"PTA","count":2,"path":"api/tags/PTA.json"},{"name":"线性结构","slug":"线性结构","count":1,"path":"api/tags/线性结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82\"><span class=\"toc-text\"> 题目要求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#input-specification\"><span class=\"toc-text\"> Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#output-specification\"><span class=\"toc-text\"> Output Specification:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\"> 解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\"> 示例代码</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"PTA数据结构08","uid":"b48181ff5fc549c282670b2e3976c524","slug":"PTA数据结构08","date":"2021-12-01T04:36:21.000Z","updated":"2021-12-31T15:00:08.319Z","comments":true,"path":"api/articles/PTA数据结构08.json","keywords":null,"cover":null,"text":" 题目要求 ​ 因为一棵二叉树的遍历可以用堆栈来模拟，故现在通过输入模拟堆栈的出入栈过程，据此建立一棵二叉树，并将其后序遍历结果输出 Input Specification: 6 Push 1 Push 2 Push 3 Pop Pop Push 4 Pop Pop Push 5...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"题目集","slug":"题目集","count":2,"path":"api/categories/题目集.json"}],"tags":[{"name":"PTA","slug":"PTA","count":2,"path":"api/tags/PTA.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"}],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{}}