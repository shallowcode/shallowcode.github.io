{"title":"数据结构","uid":"81579b6c641dedc829a2b0058112fc0c","slug":"数据结构","date":"2022-07-27T10:16:02.000Z","updated":"2022-07-28T12:39:54.099Z","comments":true,"path":"api/articles/数据结构.json","keywords":null,"cover":null,"content":"<h2 id=\"1-RMQ-st表\"><a href=\"#1-RMQ-st表\" class=\"headerlink\" title=\"1.RMQ-st表\"></a>1.RMQ-st表</h2><p>离线查询区间最值</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">template&lt;class T, class Cmp &#x3D; less&lt;T&gt;&gt; &#x2F;&#x2F;定义模版：数据类型和比较方式，默认广义小于\nstruct RMQ&#123;\n    const int n;&#x2F;&#x2F;数组长度[0, n)\n    const Cmp cmp;&#x2F;&#x2F;比较方式\n    vector&lt;vector&lt;T&gt;&gt; a;&#x2F;&#x2F;st表\n    RMQ(const vector&lt;T&gt;&amp; init) : n(init.size()), cmp(Cmp())&#123;\n        int lg &#x3D; log2(n);\n        a.assign(n, vector&lt;T&gt;(lg + 1));&#x2F;&#x2F;用n个vector&lt;T&gt;(lg + 1)填充a\n        for (int j &#x3D; 0; j &lt;&#x3D; lg; ++j)&#123;\n            for (int i &#x3D; 0; i + (1 &lt;&lt; j) &lt;&#x3D; n; ++i)&#123;\n                a[i][j] &#x3D; (j &#x3D;&#x3D; 0 ? init[i] : min(a[i][j - 1], a[i + (1 &lt;&lt; (j - 1))][j - 1], cmp));\n            &#125;\n        &#125;\n    &#125;\n    T range(int l, int r)&#123;&#x2F;&#x2F;查询[l, r]\n        int k &#x3D; log2(r - l + 1);\n        return min(a[l][k], a[r - (1 &lt;&lt; k) + 1][k], cmp);\n    &#125;\n&#125;;</code></pre>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">RMQ&lt;int, greater&lt;&gt;&gt; rmq1;&#x2F;&#x2F;最大值\nRMQ&lt;int, less&lt;&gt;&gt; rmq2;&#x2F;&#x2F;最小值</code></pre>\n<h2 id=\"2-线段树-单点修改，区间最大值查询-不带lazy-tag\"><a href=\"#2-线段树-单点修改，区间最大值查询-不带lazy-tag\" class=\"headerlink\" title=\"2.线段树-(单点修改，区间最大值查询)(不带lazy tag)\"></a>2.线段树-(单点修改，区间最大值查询)(不带lazy tag)</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void add(int p, int l, int r, int pos, int x)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        ans[p] &#x3D; (ans[p] + a + x) % mod;&#x2F;&#x2F;替换为修改\n        return;\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    if (pos &lt;&#x3D; mid) add(p &lt;&lt; 1, l, mid, pos, x);\n    else add(p &lt;&lt; 1 | 1, mid + 1, r, pos, x);\n    ans[p] &#x3D; max(ans[p &lt;&lt; 1], ans[p &lt;&lt; 1 | 1]);\n&#125;\nint query(int p, int l, int r, int nl, int nr)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        return ans[p];\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1, res &#x3D; 0;\n    if (nl &lt;&#x3D; mid) res &#x3D; max(res, query(p &lt;&lt; 1, l, mid, nl, nr));\n    if (nr &gt; mid) res &#x3D; max(res, query(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr));\n    return res;\n&#125;</code></pre>\n<h2 id=\"3-线段树-区间加，区间和查询-（带lazy-tag）\"><a href=\"#3-线段树-区间加，区间和查询-（带lazy-tag）\" class=\"headerlink\" title=\"3.线段树-(区间加，区间和查询)（带lazy tag）\"></a>3.线段树-(区间加，区间和查询)（带lazy tag）</h2><p>对于区间加和区间乘同时存在的问题，一定要先区间乘后区间加，同时在lazy tag方面要注意加法的tag要小心</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void build(int p, int l, int r)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        ans[p] &#x3D; a[l];\n        return;\n    &#125;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    build(p &lt;&lt; 1, l, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, r);\n    ans[p] &#x3D; ans[p &lt;&lt; 1] + ans[p &lt;&lt; 1 | 1];\n&#125;&#x2F;&#x2F;递归建树，p管理的节点为自己的时候直接赋值\nvoid push_down(int p, int l, int r)&#123;\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    ans[p &lt;&lt; 1] +&#x3D; (mid - l + 1) * lazy[p];\n    ans[p &lt;&lt; 1 | 1] +&#x3D; (r - mid) * lazy[p];\n    lazy[p &lt;&lt; 1] +&#x3D; lazy[p];\n    lazy[p &lt;&lt; 1 | 1] +&#x3D; lazy[p];\n    lazy[p] &#x3D; 0;\n&#125;&#x2F;&#x2F;向下传递，在更新或者查询时当前节点不完全被覆盖则向下传递lazytag\nvoid add(int p, int l, int r, int nl, int nr, int x)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        ans[p] +&#x3D; (r - l + 1) * x;\n        lazy[p] +&#x3D; x;\n        return;\n    &#125;\n    push_down(p, l, r);\n    int mid &#x3D; (l + r) &gt;&gt; 1;\n    if (nl &lt;&#x3D; mid) add(p &lt;&lt; 1, l, mid, nl, nr, x);\n    if (nr &gt; mid) add(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr, x);\n    ans[p] &#x3D; ans[p &lt;&lt; 1] + ans[p &lt;&lt; 1 | 1];\n&#125;\nll query(int p, int l, int r, int nl, int nr)&#123;\n    if (l &gt;&#x3D; nl &amp;&amp; r &lt;&#x3D; nr)&#123;\n        return ans[p];\n    &#125;\n    push_down(p, l, r);\n    int res &#x3D; 0, mid &#x3D; (l + r) &gt;&gt; 1;\n    if (nl &lt;&#x3D; mid) res +&#x3D; query(p &lt;&lt; 1, l, mid, nl, nr);\n    if (nr &gt; mid) res +&#x3D; query(p &lt;&lt; 1 | 1, mid + 1, r, nl, nr);\n    return res;\n&#125;</code></pre>\n<h2 id=\"4-树状数组护差分数组，支持单点查询，区间修改\"><a href=\"#4-树状数组护差分数组，支持单点查询，区间修改\" class=\"headerlink\" title=\"4. 树状数组护差分数组，支持单点查询，区间修改\"></a>4. 树状数组护差分数组，支持单点查询，区间修改</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">const int maxn;&#x2F;&#x2F;数组长度扩2倍\nstruct BIT&#123;\n    int c[maxn];\n    void add(int x, int k)&#123;\n        while (x &lt;&#x3D; maxn)&#123;\n            c[x] +&#x3D; k;\n            x +&#x3D; x &amp; -x;\n        &#125;\n    &#125;\n    int query(int x)&#123;\n        int res &#x3D; 0;\n        while (x)&#123;\n            res +&#x3D; c[x];\n            x -&#x3D; x &amp; -x;\n        &#125;\n        return res;\n    &#125;\n&#125;tree;</code></pre>\n<p>例题：你可以进行以下3种操作</p>\n<ol>\n<li>增加一个区间</li>\n<li>删除一个区间</li>\n<li>查询有多少个区间包含x+k*t 其中x值给定，k是固定值在操作之前给出</li>\n</ol>\n<p>首先考虑k=0的情况，用树状数组维护差分数组单点查询即可，先做一次离散化再操作</p>\n<p>当k不为0时，考虑将L，R， X对k取模，结果由[0, k - 1] 映射到[1, k]上，取模之前，如果区间长度大于k直接在[1,k] 上都加1</p>\n<p>反之，考虑l &gt;r时，对[l, k] 和[1, r] 进行操作</p>\n","text":"1.RMQ-st表离线查询区间最值 template&lt;class T, class Cmp &#x3D; less&lt;T&gt;&gt; &#x2F;&#x2F;定义模版：数据类型和比较方式，默认广义小于 struct RMQ&#123; const int n;&#x...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-RMQ-st%E8%A1%A8\"><span class=\"toc-text\">1.RMQ-st表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9F%A5%E8%AF%A2-%E4%B8%8D%E5%B8%A6lazy-tag\"><span class=\"toc-text\">2.线段树-(单点修改，区间最大值查询)(不带lazy tag)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8C%BA%E9%97%B4%E5%8A%A0%EF%BC%8C%E5%8C%BA%E9%97%B4%E5%92%8C%E6%9F%A5%E8%AF%A2-%EF%BC%88%E5%B8%A6lazy-tag%EF%BC%89\"><span class=\"toc-text\">3.线段树-(区间加，区间和查询)（带lazy tag）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%8A%A4%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%8C%E6%94%AF%E6%8C%81%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">4. 树状数组护差分数组，支持单点查询，区间修改</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"二分","uid":"8038215b5c2b5aa82664c7d7c50d2cdc","slug":"二分","date":"2022-09-28T02:43:27.000Z","updated":"2022-09-28T08:02:23.629Z","comments":true,"path":"api/articles/二分.json","keywords":null,"cover":null,"text":"二分答案前提：满足答案单调性，当求解一个问题过程需要考虑的因素比较复杂，很难通过已知要素直接推断出结果，而且因素之间互相影响， 则考虑二分答案，或者更明显的求最小值的最大值，最大值的最小值 格式不断缩减解空间的大小，整数缩减到1，浮点数缩减到精度eps int l, r; whi...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"math","uid":"d176c206991d53e1e298250d745ffd4f","slug":"math","date":"2022-07-22T13:11:52.000Z","updated":"2022-10-07T16:02:42.632Z","comments":true,"path":"api/articles/math.json","keywords":null,"cover":null,"text":" 质数分解定理：x = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}*{p_4}^{k_4}*···{p_n}^{k_n} &#x2F;&#x2F;试除法 int x; for (int i &#x3D; 2; i * i &lt;&#x3D; x; +...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}