{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2022-04-03T10:34:08.000Z","updated":"2022-06-05T02:57:59.050Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":null,"content":"<h2 id=\"并查集\"><a class=\"markdownIt-Anchor\" href=\"#并查集\"></a> 并查集</h2>\n<p>意义：</p>\n<p>可以表示某一类东西是同种类，可以表示连通块，可以表示某几件事情有关系，具体什么关系再设计一个维度计算</p>\n<ul>\n<li>食物链中的带权并查集，如果两个动物有关系，就划分到同一区域，具体什么关系再推导一下</li>\n<li>01字符串的某一子串的含1数量是奇数还是偶数，可以利用前缀的思想分成两段，则如果[x,y]的含1数是奇数则可表示为[0,x-1]含1数是奇数和[0,y]含1数是偶数有关系，或者表示为[0,x-1]含1数是偶数和[0,y]含1数是奇数有关系，这里的有关系就更直白的告诉你这两件事情会同时发生</li>\n<li>n个游戏机，某几个游戏机连到一起时就可以玩某个游戏，可以用map数组来实现，map数组里每个元素存放着某种游戏已经有几个机器连在一起了，（实际上是某个连通块随便找个父节点管理这个连通块的机器连通情况）当遇到新的链接时，将连通块小的连到大的上，同时更新连通块信息，小的连通块清除</li>\n<li>对于不给出关系而是直接给出若干点让你判断关系，如【NOIP2017奶酪】让你寻找能通上下的连通块，可以暴力每次都和之前的所有元素比较，也可以搜索直接找（对于这种题目觉得真没别的办法的话就直接暴力吧）</li>\n</ul>\n<p>并查集是一种用来管理元素分组情况的数据结构，并查集可以高效地进行如下操作：</p>\n<ul>\n<li>查询元素a和b是否属于同一组</li>\n<li>合并元素a和b所在的组</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n;&#x2F;&#x2F;一共有n个数据\n\nint fa[max_n+1];&#x2F;&#x2F;保存每个结点的父亲节点，其中根的父结点是自己\nint h[max_n+1];&#x2F;&#x2F;保存树的高度，避免退化影响复杂度\n&#x2F;&#x2F;map&lt;int,int&gt;fa;\nvoid init()&#123;\n    for (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n        fa[i]&#x3D;i;\n    &#125;\n&#125;&#x2F;&#x2F;初始化每个节点的父节点是自己\n\nint find(int x)&#123;\n    if(fa[x]&#x3D;&#x3D;x) return x;\n    else return fa[x]&#x3D;find(fa[x]);\n&#125;&#x2F;&#x2F;找一个节点的根节点，顺便把自己直接连到根节点上-路径压缩\n\n&#x2F;&#x2F;常规合并\nvoid common_unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    fa[x]&#x3D;y;\n&#125;\n&#x2F;&#x2F;启发式合并\nvoid unit(int x,int y)&#123;\n    x&#x3D;find(x),y&#x3D;find(y);\n    if(x!&#x3D;y)&#123;\n        if(h[x]&lt;h[y]) fa[x]&#x3D;y;\n        else fa[y]&#x3D;x;\n        if(h[x]&#x3D;&#x3D;h[y]) h[x]++;\n    &#125;\n&#125;&#x2F;&#x2F;高度小的树作为高度大的树的子节点，树的高度在两树相等的时候更新</code></pre>\n<p>建立一个数据结构，满足以下操作</p>\n<ol>\n<li>插入一个数</li>\n<li>删除一个数</li>\n<li>查询序列未出现过的最小正整数</li>\n</ol>\n<p>方法：建立一个set表示未出现过的数的集合，设立一个数组或map表示插入的数出现过的次数，当出现过次数变为0时应该在set中加入该数，表示现在该数不存在</p>\n<p>利用重载()运算符，来使set容器中的部分元素成为一个整体，达到以一映多的目的</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct cmp&#123;\n    bool operator ()(const int a, const int b)&#123;\n        if(abs(a-b)&lt;&#x3D;k)return false;\n        return a&lt;b;\n    &#125;\n&#125;\nset&lt;int,cmp&gt;s;\n&#x2F;&#x2F;以下两种函数的运作方式是创造一个新的对象然后通过比较的方式在set中寻找满足条件的元素\ns.find(x);&#x2F;&#x2F;寻找与x相差不超过k的元素\ns.erase(x);&#x2F;&#x2F;将与x相差不超过k的元素全部删除</code></pre>\n","text":" 并查集 意义： 可以表示某一类东西是同种类，可以表示连通块，可以表示某几件事情有关系，具体什么关系再设计一个维度计算 食物链中的带权并查集，如果两个动物有关系，就划分到同一区域，具体什么关系再推导一下 01字符串的某一子串的含1数量是奇数还是偶数，可以利用前缀的思想分成两段，则...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"程序设计","slug":"程序设计","count":2,"path":"api/categories/程序设计.json"}],"tags":[{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\"> 并查集</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"集合","uid":"be4fadc0757b3a2eeaefd20302787665","slug":"集合","date":"2022-04-04T04:58:47.000Z","updated":"2022-04-04T05:02:22.012Z","comments":true,"path":"api/articles/集合.json","keywords":null,"cover":null,"text":" 题目要求 Caima 给你了所有**[a,b]**范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 p的公共质因数，那么把它们所在的集合合并。重复如上操作，直到没有可以合并的集合为止。现在 Caima 想知道，最后有...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"程序设计","slug":"程序设计","count":2,"path":"api/categories/程序设计.json"}],"tags":[{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"},{"name":"埃尔筛法","slug":"埃尔筛法","count":1,"path":"api/tags/埃尔筛法.json"}],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"share","uid":"d78199dbabc681e201328dc8f8002dc2","slug":"share","date":"2022-01-22T09:06:40.000Z","updated":"2022-01-22T09:06:40.237Z","comments":true,"path":"api/articles/share.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}