{"title":"dp入门","uid":"8b03c71c44a90bad729a0bac36f3314d","slug":"dp入门","date":"2022-11-15T00:32:38.000Z","updated":"2022-11-15T02:01:09.804Z","comments":true,"path":"api/articles/dp入门.json","keywords":null,"cover":null,"content":"<h2 id=\"线性dp\"><a href=\"#线性dp\" class=\"headerlink\" title=\"线性dp\"></a>线性dp</h2><h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><ul>\n<li>概率相关的dp可以转化为计数dp</li>\n<li>求最小值要全体赋值并初始化状态</li>\n<li>dp构造方法：考虑题目每个要素是否可以作为枚举时的一个维度，考虑转移是否方便，复杂度等问题</li>\n<li>贪心地进行转移：在转移过程中若当前状态可以有多种转移的手段，有时只需贪心的取其中的极端情况</li>\n<li>求起点到终点，终点到起点两条路径往往可以转化为起点到终点满足条件的两条路径</li>\n</ul>\n<h4 id=\"免费馅饼\"><a href=\"#免费馅饼\" class=\"headerlink\" title=\"免费馅饼\"></a>免费馅饼</h4><p>Q：一个人最开始站在x轴某处，有若干馅饼会在$t_i$时刻出现在$x_i$位置，拥有$v_i$的价值，当且仅当这个人和馅饼同时出现在一个位置可以拿到价值，每秒这个人可以选择移动k格，求这个人能拿到的最大价值，以及为了拿到该价值每秒的决策（该问题扩展数据后需要数据结构优化dp）</p>\n<p>A：考虑给出的因素，令$dp[i][j]$为在$i位置，j时刻，所获得得最大值$, 考虑转移</p>\n<script type=\"math/tex; mode=display\">\ndp[i][j]=max\\{dp[i + k][j + 1] + v[i][j]\\}</script><p>如果按时间从小到大转移的话，会不断更新上一秒的决策，所以采用时间倒着遍历，更新这一秒的决策，即如果能转移到这个状态，我下一步这样走，最优</p>\n<h4 id=\"过河\"><a href=\"#过河\" class=\"headerlink\" title=\"过河\"></a>过河</h4><p>Q：一群人想过河，有一条船，最多一次过两个人，时间取两个人的最大值，问最小花费多长时间将所有的人都送到河对岸</p>\n<p>A：先排序，考虑送$i$个人过桥，可以是已经送$i-1$个人过桥，然后让速度最快的人回来送第$i$个人过桥，或者送$i-2$个人过桥，速度最快的人回来然后让较慢的俩人过桥，速度第二快的人回来和速度最快的人一起过桥</p>\n<h4 id=\"最大子矩阵\"><a href=\"#最大子矩阵\" class=\"headerlink\" title=\"最大子矩阵\"></a>最大子矩阵</h4><p>Q：给定一个矩阵，其中列数不超过2，在其中选择k个不重叠的矩阵，使得所有矩阵中的元素加起来的和最大</p>\n<p>A：对于列数为2的情况，令$dp[i][j][k]$为第一列便利到$i$，第二列遍历到$j$选择了$k$个矩阵所获的最大值，转移时要注意存在宽为2矩阵</p>\n<h3 id=\"最大上升子列\"><a href=\"#最大上升子列\" class=\"headerlink\" title=\"最大上升子列\"></a>最大上升子列</h3><ol>\n<li>$O(n^2)$算法考虑以$a_i$为结尾的最长上升子列,令$dp[i]$为以$a_i$为结尾的最长上升子列，显然有</li>\n</ol>\n<script type=\"math/tex; mode=display\">\ndp[i]=max\\{1,dp[j]+1\\ |j<i\\ 且\\ a_j<a_i\\}</script><ol>\n<li>$O(nlogn)$算法:考虑相同长度的最大上升子列，结尾的值越小越好,令$dp[i]$为长度$i+1$以$a_i$结尾的最长上升子列若$dp[i-1]&lt;a_j$则可以更新$dp[i]$的值注意，初始化$dp[0]$可以随意更新，且由于$dp[i]$除$INF$外单调递增，故用二分查找每次更新$a_j$的位置</li>\n</ol>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">memset(dp,0x3f,sizeof(dp));\n&#x2F;&#x2F;full(dp,dp+n,INF);\n&#x2F;&#x2F;reverse(a,a+n);&#x2F;&#x2F;最大下降子列或最大不下降子列\nfor (int i&#x3D;0;i&lt;n;++i)&#123;\n    *lower_bound(dp,dp+n,a[i])&#x3D;a[i];&#x2F;&#x2F;最大上升子列\n    &#x2F;&#x2F;*upper_bound(dp,dp+n,a[i])&#x3D;a[i];&#x2F;&#x2F;最大不下降子列\n&#125;\ncout &lt;&lt; lower_bound(dp,dp+n,INF) - dp &lt;&lt; &#39;\\n&#39;;</code></pre>\n<p>$最长递增子列的长度\\Leftrightarrow 数列可划分的最少的不递增序列的个数$</p>\n<p>$最长不递增子列的长度\\Leftrightarrow 数列可划分的最少的递增序列的个数$</p>\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><h4 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h4><p>Q：每个元素有一定花费，有一定价值，只能拿一次，给定最大花费，求最大价值</p>\n<p>A：令$dp[i][j]$为考虑前$i$个物品花费$j$取得的最大价值，有</p>\n<script type=\"math/tex; mode=display\">\ndp[i][j]=max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</script><p>$j$永远由更小的值转移而来，所以去掉第一维</p>\n<script type=\"math/tex; mode=display\">\ndp[j]=max(dp[j], dp[j - v[i]] + w[i])\\ \\ \\ j由大到小枚举</script><p>变式1：Q：有若干物品分给两个人，使其重量差值最小</p>\n<p>​              A：设重量总和为sum，即对sum&gt;&gt;1做01背包</p>\n<p>变式2：Q：对于维度之间互相有限制的关系的时候，可以先锁定一个维度再进行计算</p>\n<h4 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h4><p>Q：01背包基础上每个元素可以拿无限次</p>\n<p>A：</p>\n<script type=\"math/tex; mode=display\">\ndp[i][j] = max(dp[i - 1][j-k*v[i]]+k*w[i])(k*v[i]\\leqslant j)</script><script type=\"math/tex; mode=display\">\ndp[j]=max(dp[j], dp[j - v[i]] + w[i])\\ \\ \\ j由小到大枚举</script><h4 id=\"分组背包\"><a href=\"#分组背包\" class=\"headerlink\" title=\"分组背包\"></a>分组背包</h4><p>Q：有$n$组，最大花费为$v$，每组有$w$种选择可以选择一个</p>\n<p>A：常规做法：01背包，先从大到小枚举花费，再枚举每组的情况，时间复杂度：$O(nvw)$，空间复杂度：$O(v)$</p>\n<p>变式：有n组，最大花费为v，每组若想选择则必须选择物品$A$，剩下$j$个任意选择</p>\n<p>法1:暴力枚举出$2^j$种方案，按常规分组背包做，时间复杂度：$O(nv2^j)$,空间复杂度：$O(v)$</p>\n<p>法2:令 $dp[i][j]$为前 $i$个组花费为$j$的最大价值，时间复杂度：$O(nvj)$，空间复杂度：$O(nv)$</p>\n<script type=\"math/tex; mode=display\">\ndp[i][j]=dp[i-1][j](不选择该组) \\\\\ndp[i][j]=dp[i-1][j-a[i]](选择该组),然后01背包 \\\\\n要注意更新顺序，不选择该组应该最后更新</script><h2 id=\"区间dp\"><a href=\"#区间dp\" class=\"headerlink\" title=\"区间dp\"></a>区间dp</h2><h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>最小子空间不是线性的，往往需要你把任意一段都当成开始的区间</p>\n<h4 id=\"合并回文字串\"><a href=\"#合并回文字串\" class=\"headerlink\" title=\"合并回文字串\"></a>合并回文字串</h4><p>Q：有两个字符串$s_1,s_2$，将其合并成一个新的字符串，属于各自的字符按照原字符串顺序排列，求最大的回文字符串长度</p>\n<p>A：考虑$dp[i][j][k][q]$为$s_1[i][j]到 s_2[k][q]$能合成的最大的回文字符串长度</p>\n<h4 id=\"节约能源\"><a href=\"#节约能源\" class=\"headerlink\" title=\"节约能源\"></a>节约能源</h4><p>Q：若干路灯排成一行，每个路灯每秒都在持续消耗能量，一个人从其中一个路灯出发，问关掉所有路灯所花费的最少能量</p>\n<p>A：令$dp[i][j]$为关掉$i$到$j$所花费的最小能量，由于关掉一段路灯之后这个人在这段的左边还是右边对接下来的答案有影响，所以令$dp[i][j],j \\leqslant i$为关掉这一区间后停在这一段的右边，路灯消耗的能量通过前缀和预处理</p>\n<h4 id=\"传纸条\"><a href=\"#传纸条\" class=\"headerlink\" title=\"传纸条\"></a>传纸条</h4><p>Q：在一个$n*m$大小的矩阵中，从左上角向右下角传纸条，经过的位置可拿走其中的数，寻找两条不相交的路径，使得拿走的总数最大</p>\n<p>A：设置$dp[i][j][k]$使得一共走了$k$步，第一条路径走到$i$行，第二条路径走到$j$行，所获的的最大值，正常$dp$转移即可，让两条路径同时在一个位置时只拿到一次数字即可，这样如果不可能有交叉</p>\n<h4 id=\"合成数字\"><a href=\"#合成数字\" class=\"headerlink\" title=\"合成数字\"></a>合成数字</h4><p>Q：给出一列数，相邻两个数如果相同则可以合成一个数并加一，求这一列数能产生的最大数</p>\n<p>A：$dp[i][j]$代表下标从$j$开始合成数字$i$需要到达最近的下标，如果不能合成结果为0，转移方程为</p>\n<script type=\"math/tex; mode=display\">\ndp[i][j] = dp[i-1][dp[i-1][j]]</script>","text":"线性dp技巧 概率相关的dp可以转化为计数dp 求最小值要全体赋值并初始化状态 dp构造方法：考虑题目每个要素是否可以作为枚举时的一个维度，考虑转移是否方便，复杂度等问题 贪心地进行转移：在转移过程中若当前状态可以有多种转移的手段，有时只需贪心的取其中的极端情况 求起点到终点，终...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7dp\"><span class=\"toc-text\">线性dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC\"><span class=\"toc-text\">免费馅饼</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%B2%B3\"><span class=\"toc-text\">过河</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">最大子矩阵</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%88%97\"><span class=\"toc-text\">最大上升子列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">背包问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">01背包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">完全背包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">分组背包</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4dp\"><span class=\"toc-text\">区间dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">应用场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2\"><span class=\"toc-text\">合并回文字串</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%BA%A6%E8%83%BD%E6%BA%90\"><span class=\"toc-text\">节约能源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BA%B8%E6%9D%A1\"><span class=\"toc-text\">传纸条</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">合成数字</span></a></li></ol></li></ol></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"思维1500-1700","uid":"fdc2d967139f06c1554f41a568731c4c","slug":"思维1500-1700","date":"2022-11-15T00:26:17.000Z","updated":"2022-11-15T00:26:24.074Z","comments":true,"path":"api/articles/思维1500-1700.json","keywords":null,"cover":null,"text":" codeforces#823-div2-B 题意：一维坐标系有n个人，各自的坐标为xix_ixi​，每个人需要ti的时间才能出发，问需要多长时间才能让所有人聚集到一个地方 解答：若每个人所需要的时间tit_iti​都是0的话，则答案为xmax+xmin2\\frac{x_{max...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}