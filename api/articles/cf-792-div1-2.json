{"title":"cf-792-div1+2","uid":"ec879031a4be3590103f0fd58b750e46","slug":"cf-792-div1-2","date":"2022-05-20T15:40:39.000Z","updated":"2022-05-24T12:42:29.107Z","comments":true,"path":"api/articles/cf-792-div1-2.json","keywords":null,"cover":null,"content":"<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h2><p>题意：给定一个矩阵，你可以将任意两列交换至多一次，问能否使矩阵每一行不下降</p>\n<p>方法：读入矩阵，对每一行重新排序，若与原序列不同则加入有问题数组，数组长度大于2则不可能交换一次解决，否则将矩阵交换该两列，看是否满足答案</p>\n<p>题意：给定一个2行n列的矩阵，可以任意交换两列，问能否使矩阵的每一行都不下降</p>\n<h2 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h2><p>题意：给定n个陷阱，你需要按顺序走过这些陷阱，每个陷阱会对你造成固定伤害，你可以跳过k个陷阱，但是每跳过一个陷阱后续所有的陷阱造成的伤害都会加一，求走完n个陷阱所受到的最小伤害</p>\n<p>方法：</p>\n<p>首先贪心的考虑一定要用完所有跳过的机会，如果不想让后面的陷阱变大跳过最后一个便是了，其次考虑跳过每个陷阱所减少的伤害数：</p>\n<p>$若跳过第i个陷阱，则减少伤害a[i]但其后面会增加n-i点伤害,又因为后面有k-1次跳过机会再减去k-1，把\\\\k提出来，考虑-a[i]+n-i,排序取前k个得出答案$</p>\n<h2 id=\"793-Div2\"><a href=\"#793-Div2\" class=\"headerlink\" title=\"793-Div2\"></a>793-Div2</h2><h2 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h2><p>题意：给定0～n-1的一个无序排列，现在可以任意交换$a_i$和$a_j$任意多次，前提是$a_i\\&amp;a_j=x$使得排列有序，求最大的x</p>\n<p>$对于每个a_i和i不同的位置，该元素必须要交换，在二进制的情况考虑，若a_i的二进制位是0，\\\\x不可以为1，而为了取最大值a_i二进制为1的位置，x尽量为1，\\\\综合考虑，将所有不符合条件的a_i与起来得到x，x即为最大的，\\\\由于x在排列中，可借助中转站实现任意两个元素交换，a\\&amp;b\\&amp;c···=x,则a\\&amp;x=x$</p>\n<h2 id=\"C-1\"><a href=\"#C-1\" class=\"headerlink\" title=\"C\"></a>C</h2>","text":"C题意：给定一个矩阵，你可以将任意两列交换至多一次，问能否使矩阵每一行不下降 方法：读入矩阵，对每一行重新排序，若与原序列不同则加入有问题数组，数组长度大于2则不可能交换一次解决，否则将矩阵交换该两列，看是否满足答案 题意：给定一个2行n列的矩阵，可以任意交换两列，问能否使矩阵的...","link":"","photos":[],"count_time":{"symbolsCount":648,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C\"><span class=\"toc-text\">C</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#D\"><span class=\"toc-text\">D</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#793-Div2\"><span class=\"toc-text\">793-Div2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B\"><span class=\"toc-text\">B</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-1\"><span class=\"toc-text\">C</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"特殊的数据结构","uid":"cf16dcad745c39bc496f066c73c8929e","slug":"特殊的数据结构","date":"2022-05-21T14:49:59.000Z","updated":"2022-05-21T14:53:34.100Z","comments":true,"path":"api/articles/特殊的数据结构.json","keywords":null,"cover":null,"text":"维护序列中最小未出现过的非负整数，支持插入，查询，删除用一个数组记录每个数出现过的次数，用set维护一个按大小排列的未出现过数 int cot[maxnum]; set&lt;int&gt;st; int m; int op, x; void solve() &#123; for...","link":"","photos":[],"count_time":{"symbolsCount":611,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"搜索","uid":"3ae07ab74ec1bcb36882cc1ce0d929c6","slug":"搜索","date":"2022-05-12T00:57:55.000Z","updated":"2022-07-11T14:22:33.791Z","comments":true,"path":"api/articles/搜索.json","keywords":null,"cover":null,"text":"搜索剪枝小木棍有一些同样长的小木棍，将这些木棍随意切割，得到若干小木棍，已知这些小木棍的长度，求最小的初始木棍原长 1.搜索 根据一根木棍的拼接来确定搜索的参数，设立： 还有多少木棍没有进行拼接 当前拼接的木棍还需要多少长度 目标木棍长度 现在处理第几根木棍 vector&lt;...","link":"","photos":[],"count_time":{"symbolsCount":882,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}