{"title":"搜索","uid":"3ae07ab74ec1bcb36882cc1ce0d929c6","slug":"搜索","date":"2022-05-12T00:57:55.000Z","updated":"2022-07-22T13:05:00.646Z","comments":true,"path":"api/articles/搜索.json","keywords":null,"cover":null,"content":"<h1 id=\"搜索剪枝\"><a href=\"#搜索剪枝\" class=\"headerlink\" title=\"搜索剪枝\"></a>搜索剪枝</h1><h3 id=\"小木棍\"><a href=\"#小木棍\" class=\"headerlink\" title=\"小木棍\"></a>小木棍</h3><p>有一些同样长的小木棍，将这些木棍随意切割，得到若干小木棍，已知这些小木棍的长度，求最小的初始木棍原长</p>\n<p>1.搜索</p>\n<p>根据一根木棍的拼接来确定搜索的参数，设立：</p>\n<ul>\n<li><p>还有多少木棍没有进行拼接</p>\n</li>\n<li><p>当前拼接的木棍还需要多少长度</p>\n</li>\n<li>目标木棍长度</li>\n<li>现在处理第几根木棍</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; a(n + 1);\nvector&lt;bool&gt; vis(n + 1);&#x2F;&#x2F;利用vis数组来避免重复搜索\nbool dfs(int num, int rest, int len, int k)&#123;\n    if (num &#x3D;&#x3D; 0 &amp;&amp; rest &#x3D;&#x3D; 0)&#123;\n        return true;\n    &#125;\n    if (rest &#x3D;&#x3D; 0)&#123;\n        rest &#x3D; len;\n        k &#x3D; 1;\n    &#125;\n    for (int i &#x3D; k; i &lt;&#x3D; n; ++i)&#123;\n        if (!vis[i])&#123;\n            vis[i] &#x3D; 1;\n            if (dfs(num - 1, rest - a[i], len, i))&#123;\n                return true;\n            &#125;\n            vis[i] &#x3D; 0;\n        &#125;\n    &#125;\n    return false;\n&#125;</code></pre>\n<p>2.剪枝</p>\n<p>顾名思义，减去解答树的部分“枝条”，对于正在拼接的一根木棍而言，如果第一根小木棍就不能满足或者作为最后一根小木棍满足但是后续不满足，就不用考虑其他的小木棍了，且与其长度相同的小木棍也不用考虑了，由此，可以先预处理将所有小木棍由高到低排序，再进行下列操作</p>\n<h3 id=\"dfs\"><a href=\"#dfs\" class=\"headerlink\" title=\"dfs\"></a>dfs</h3><p>递归搜索，将要搜索的目标分成若干层，每层基于前几层的状态进行决策，直到达到目标状态</p>\n<p>大致结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; u可以是节点或者一种抽象的状态\ndfs(u) &#123;\n  1.判断是否达到目标状态 -&gt; return;\n  2.标记u这个状态访问过了\n  3.for u 可以延伸到的状态 v：\n  \t  如果v没有被访问到\n  \t  dfs(v);\n  \tend\n  end\n&#125;</code></pre>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ul>\n<li><p>连通块的计算</p>\n</li>\n<li><p>生成每一位都是7或4的数</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; pos;\nvoid dfs(int k)&#123;\n    pos.push_back(k);\n    dfs(k * 10 + 4);\n    dfs(k * 10 + 7);\n&#125;\ndfs(4);dfs(7);</code></pre>\n</li>\n<li><p>染色法</p>\n</li>\n</ul>\n<h3 id=\"bfs\"><a href=\"#bfs\" class=\"headerlink\" title=\"bfs\"></a>bfs</h3><p>从每个状态节点一层一层的往外找，所以是寻找初始状态到目标状态最短距离的搜索手段</p>\n<p>大致结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bfs()&#123;\n  1.将初始状态节点放入队列\n  2.标记初始状态节点为已访问过\n  while(队列不为空)&#123;\n    1.取队首状态节点\n    2如果是目标节点，直接返回累计的最短路长\n    3.这个状态能延伸到的节点v，如果没有被访问到 -&gt;bfs(v)\n  &#125;\n&#125;</code></pre>\n<p>应用：</p>\n<ul>\n<li><p>字符串变换</p>\n<p>几个技巧：</p>\n<ol>\n<li>利用map<string, node> 可以同时储存状态本身的信息和状态是否被访问的信息，只需要在队列中入队string即可</li>\n<li>string 字符串可以一维对应二维坐标，然后就像走迷宫一样改变状态</li>\n</ol>\n</li>\n<li><p>状态设计</p>\n<p>当状态涉及到多个元素是否取得的时候而且n比较小, 可以用</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int ans &#x3D; 0;\nfor (int i &#x3D; 0; i &lt; n; ++i)&#123;\n    if (取)&#123;\n        ans |&#x3D; 1 &lt;&lt; i;\n    &#125;\n&#125;</code></pre>\n<p>来用一个较大整数的二进制位数来确定状态</p>\n</li>\n<li><p>状态确定</p>\n<ul>\n<li><p>给出一个地图，两个人同时从一个起点出发，问经过多长时间可以两人可以走完地图</p>\n<p>正常bfs，但需要考虑一点就是，状态的确定问题</p>\n<p>vis数组应该同时考虑两人的位置以及两人现在走过的地图大小，走过的地图大小可以坐标二维转化为一维然后通过二进制储存在一个较大的数里</p>\n</li>\n</ul>\n</li>\n<li><p>传送阵（改变状态转移方式的东西）</p>\n<ul>\n<li><p>传送阵可以选择传送也可以选择不传送</p>\n<ul>\n<li><p>优先队列bfs</p>\n<p>传送阵可以通过额外的时间传送到另一个位置</p>\n</li>\n<li><p>0-1 bfs</p>\n<p>通过deque来使得队列一直取得最小值，即状态改变有多种选择但是平常不进行状态改变</p>\n<p>状态改变的节点放到后面先处理状态改变比较少的状态</p>\n</li>\n</ul>\n</li>\n<li><p>“传送阵”会永久改变状态改变方式而且必须踩到</p>\n<ul>\n<li>正常2秒一个格子，踩到车之后一秒一个格子，很明显，对于同一个位置没有车但步数少不一定最终强过有车但是暂时步数多，所以唯一区别点是有没有车，先做一个bfs找到不用车到达终点的步数，再找到所有车的最短路，再对每辆车重新做bfs和之前的加起来，比较</li>\n<li>迷宫中引入钥匙和门，同样的，先做bfs找到钥匙，不过这里不用做两次bfs，只需要在没有钥匙的时候对自己经过的点设置为门就可以了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","text":"搜索剪枝小木棍有一些同样长的小木棍，将这些木棍随意切割，得到若干小木棍，已知这些小木棍的长度，求最小的初始木棍原长 1.搜索 根据一根木棍的拼接来确定搜索的参数，设立： 还有多少木棍没有进行拼接 当前拼接的木棍还需要多少长度 目标木棍长度 现在处理第几根木棍 vector&lt;...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E5%89%AA%E6%9E%9D\"><span class=\"toc-text\">搜索剪枝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E6%9C%A8%E6%A3%8D\"><span class=\"toc-text\">小木棍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dfs\"><span class=\"toc-text\">dfs</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">应用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bfs\"><span class=\"toc-text\">bfs</span></a></li></ol></li></ol></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"cf-792-div1+2","uid":"ec879031a4be3590103f0fd58b750e46","slug":"cf-792-div1-2","date":"2022-05-20T15:40:39.000Z","updated":"2022-07-25T05:06:12.251Z","comments":true,"path":"api/articles/cf-792-div1-2.json","keywords":null,"cover":null,"text":"C题意：给定一个矩阵，你可以将任意两列交换至多一次，问能否使矩阵每一行不下降 方法：读入矩阵，对每一行重新排序，若与原序列不同则加入有问题数组，数组长度大于2则不可能交换一次解决，否则将矩阵交换该两列，看是否满足答案 题意：给定一个2行n列的矩阵，可以任意交换两列，问能否使矩阵的...","link":"","photos":[],"count_time":{"symbolsCount":864,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"技巧","uid":"c415bd8a15236b765141e56b25f1f835","slug":"技巧","date":"2022-05-11T15:58:56.000Z","updated":"2022-10-05T13:33:20.426Z","comments":true,"path":"api/articles/技巧.json","keywords":null,"cover":null,"text":"$ 用逻辑尺来暴力枚举对于n个状态的取舍的2^n种情况 $ for (int i&#x3D;0;i&lt;(1&lt;&lt;n);++i)&#123; for (int j&#x3D;0;j&lt;n;++i)&#123; if(i&lt;&lt;j&amp;1)&#123; ...","link":"","photos":[],"count_time":{"symbolsCount":658,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}