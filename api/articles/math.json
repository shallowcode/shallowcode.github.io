{"title":"math","uid":"d176c206991d53e1e298250d745ffd4f","slug":"math","date":"2022-07-22T13:11:52.000Z","updated":"2022-10-07T16:02:42.632Z","comments":true,"path":"api/articles/math.json","keywords":null,"cover":null,"content":"<ol>\n<li><p>质数分解定理：<script type=\"math/tex\">x = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}*{p_4}^{k_4}*···{p_n}^{k_n}</script></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;试除法\nint x;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; x; ++i)&#123;\n    if (x % i &#x3D;&#x3D; 0)&#123;\n        cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (x !&#x3D; 1) cout &lt;&lt; x ;</code></pre>\n</li>\n<li><p>快速幂</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">long long qpow(long long a, long long b, long long mod)&#123;\n    long long res &#x3D; 1;\n    while (b)&#123;\n        if (b &amp; 1) res &#x3D; res * a % mod;\n        a &#x3D; a * a % mod;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;</code></pre>\n</li>\n<li><p>线性筛</p>\n<p>特点：每个合数都被且仅被其最小质因子筛一次</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool isprime[maxn];&#x2F;&#x2F;对空间有要求\nvector&lt;int&gt; pos;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; maxn; ++i)&#123; &#x2F;&#x2F; 如果要筛出所有的质数这里的i的限制条件应该改一下\n    if (!isprime[i])&#123;\n        pos.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; pos.size() &amp;&amp; pos[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        isprime[i * pos[j]] &#x3D; 1;\n        if (i % pos[j] &#x3D;&#x3D; 0)&#123;\n            break;\n        &#125;\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>矩阵快速幂，矩阵加速递推</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct node&#123;\n    int a[n][n];\n    node()&#123;memset(a, 0, sizeof(a))&#125;&#x2F;&#x2F;初始化\n    node operator * (node b)&#123;\n        node x;\n        for (int i &#x3D; 0; i &lt; n; ++i)&#123;\n           for (int j &#x3D; 0; j &lt; n; ++j)&#123;\n               x[i][j] &#x3D; 0;\n               for (int k &#x3D; 0; k &lt; n; ++k)&#123;\n                   x[i][j] &#x3D; (x[i][j] + a[i][k] % MOD * b[k][j] % MOD) % MOD;\n               &#125;\n           &#125;\n        &#125;\n        return x;\n    &#125;\n&#125;;\nnode qpow(node a, long long b, long long mod)&#123;\n    if (b &#x3D;&#x3D; 1) return a;\n    node x;b--;\n    &#x2F;&#x2F;这里的处理可以直接新建一个单位矩阵，注意初始化对角线为1\n    while(b)&#123;\n        if (b &amp; 1)&#123;\n            x &#x3D; x * a;\n        &#125;\n        a &#x3D; a * a;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return x;\n&#125;</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>中国剩余定理（CRT，模数互质）</p>\n<pre class=\"line-numbers language-cpp&#123;\" data-language=\"cpp&#123;\"><code class=\"language-cpp&#123;\">vector&lt;ll&gt; mod(k + 1), yu(k + 1);\nll ans &#x3D; 0, M &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n    M *&#x3D; mod[i];\n&#125;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    ll mi &#x3D; M &#x2F; mod[i], t, y;\n    euclid(mi, mod[i], t, y);\n    t &#x3D; t % mod[i];\n    ans &#x3D; (ans + yu[i] * mi * t) % M;\n&#125;\ncout &lt;&lt; (ans + M) % M &lt;&lt; &#39;\\n&#39;;</code></pre>\n</li>\n<li><p>扩展中国剩余定理（EXCRT，模数不互质）</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;ll&gt; mod(k + 1), yu(k + 1);\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n&#125;\nll ans &#x3D; yu[1], mi &#x3D; mod[1], t &#x3D; 0, y &#x3D; 0;\nfor (int i &#x3D; 2; i &lt;&#x3D; k; ++i)&#123;\n    ll res &#x3D; ((yu[i] - ans) % mod[i] + mod[i]) % mod[i];\n    ll gcd &#x3D; euclid(mi, mod[i], t, y);\n    if (res % gcd !&#x3D; 0)&#123;cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;return 0;&#125;\n    t &#x3D; qmul(t, res &#x2F; gcd, mod[i]);\n    ans +&#x3D; t * mi;\n    mi &#x3D; mi &#x2F; gcd * mod[i];\n    ans &#x3D; (ans % mi + mi) % mi;\n&#125;\ncout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;</code></pre>\n</li>\n<li><p>欧拉函数：小于等于n，与n互质的数的个数</p>\n<p>对于$n = {p_1}^{k_1}<em>{p_2}^{k_2}</em>{p_3}^{k_3}···{p_n}^{k_n}$,$\\varphi (n)=n\\prod_{i=1}^{n}\\frac{p_i-1}{p_i}$</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;试除求单个n的欧拉函数\nint n;\nint res &#x3D; n;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; n; ++i)&#123;\n    if (n % i &#x3D;&#x3D; 0)&#123;\n        res &#x3D; res &#x2F; i * (i - 1);\n        while (n % i &#x3D;&#x3D; 0) n &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (n &gt; 1) res &#x3D; res &#x2F; n * (n - 1);\n\n&#x2F;&#x2F;筛法求1～n的欧拉函数值\nbool vis[maxn];\nvector&lt;int&gt; prime;\nint d[maxn];\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        d[i] &#x3D; i - 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; n; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (prime[j] % i &#x3D;&#x3D; 0)&#123;\n            d[m] &#x3D; d[i] * prime[j];\n            break;\n        &#125;\n        else&#123;\n            d[m] &#x3D; d[i] * (prime[j] - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>线性筛求1～n每个数的约数个数,约数和</p>\n<p>$n = {p_1}^{k_1}<em>{p_2}^{k_2}</em>{p_3}^{k_3}···{p_n}^{k_n}$</p>\n<p>约数个数=$(k_1+1)(k_2+1)(k_3+1)···(k_n+1)$</p>\n<p>约数和=$(1+p_1+p_1^2+···p_1^{k_1})···(1+p_n+p_n^2+···p_n^{k_n})$</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;约数个数根据乘法原理，维护最小的质因子个数\nbool vis[maxn];\nvector&lt;int&gt; p;\nint d[maxn];&#x2F;&#x2F;储存约数个数\nint a[maxn];&#x2F;&#x2F;最小质因子个数\n\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; 1;\n        d[i] &#x3D; 2;\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[m] * (a[m] + 1);\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1;\n            d[m] &#x3D; d[i] * 2;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;同约数个数，从最小质因子的约数和入手\nint d[maxn];&#x2F;&#x2F;约数和\nint a[maxn];&#x2F;&#x2F;最小质因子约数和\na[1] &#x3D; d[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; d[i] &#x3D; i + 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m&#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; prime[j] * a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[i] * a[m];\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1 + prime[j];\n            d[m] &#x3D; a[m] * d[i];\n        &#125;\n    &#125;\n&#125;</code></pre>\n<ol>\n<li><p>扩展欧几里得算法</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">ll exgcd(ll a, ll b, ll x, ll y)&#123;\n    return !b ? (x &#x3D; 1, y &#x3D; 0, a) : (exgcd(b, a % b, y, x), y -&#x3D; (a &#x2F; b) * x);\n&#125;</code></pre>\n</li>\n<li><p>威尔逊定理及其扩展</p>\n<p>$p$是质数的充分必要条件是$(p-1)!\\equiv -1(mod \\ p)$</p>\n<p>推论：</p>\n<ul>\n<li><p>$(p-1)!+1\\equiv0(mod \\ p)$质数的充要条件</p>\n</li>\n<li><p>$(p-1)!\\equiv0(mod \\ p)$非质数的充要条件</p>\n</li>\n</ul>\n</li>\n</ol>\n","text":" 质数分解定理：x = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}*{p_4}^{k_4}*···{p_n}^{k_n} &#x2F;&#x2F;试除法 int x; for (int i &#x3D; 2; i * i &lt;&#x3D; x; +...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"数据结构","uid":"81579b6c641dedc829a2b0058112fc0c","slug":"数据结构","date":"2022-07-27T10:16:02.000Z","updated":"2022-07-28T12:39:54.099Z","comments":true,"path":"api/articles/数据结构.json","keywords":null,"cover":null,"text":"1.RMQ-st表离线查询区间最值 template&lt;class T, class Cmp &#x3D; less&lt;T&gt;&gt; &#x2F;&#x2F;定义模版：数据类型和比较方式，默认广义小于 struct RMQ&#123; const int n;&#x...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-06-22T04:50:06.000Z","updated":"2022-06-26T17:16:45.378Z","comments":true,"path":"api/articles/队列.json","keywords":null,"cover":null,"text":"栈出栈排序给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序 对当前元素入队，如果栈顶元素大于之后的所有元素，出栈 队列插队给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}