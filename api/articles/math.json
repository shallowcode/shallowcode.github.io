{"title":"math","uid":"d176c206991d53e1e298250d745ffd4f","slug":"math","date":"2022-07-22T13:11:52.000Z","updated":"2022-10-04T05:20:26.117Z","comments":true,"path":"api/articles/math.json","keywords":null,"cover":null,"content":"<ol>\n<li>\n<p>给出一个数，输出它的所有素因子 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">1&lt;x&lt;10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></p>\n<p>解析：由质数分解定理，即任意<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">x &gt; 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>可以表示为</p>\n<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 67: …*···{p_n}^{k_n}$̲$为减少时间复杂度，直接枚举1…'>x = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}*{p_4}^{k_4}*···{p_n}^{k_n}$$为减少时间复杂度，直接枚举1 ~ $\\sqrt{x}$如果最后一个质因子\n\n只有一个筛不到，所以在结束后增加一个判断\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int x;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; x; ++i)&#123;\n    if (x % i &#x3D;&#x3D; 0)&#123;\n        cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (x !&#x3D; 1) cout &lt;&lt; x ;</code></pre>\n\n</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">long long qpow(long long a, long long b, long long mod)&#123;\n    long long res &#x3D; 1;\n    while (b)&#123;\n        if (b &amp; 1) res &#x3D; res * a % mod;\n        a &#x3D; a * a % mod;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;</code></pre>\n</li>\n<li>\n<p>线性筛（需要O(n)的空间）</p>\n<p>需要证明两点：</p>\n<ol>\n<li>每个合数都能被筛到</li>\n<li>每个合数仅被其最小的素因子筛到</li>\n</ol>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool isprime[maxn];\nvector&lt;int&gt; pos;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; maxn; ++i)&#123; &#x2F;&#x2F; 如果要筛出所有的质数这里的i的限制条件应该改一下\n    if (!isprime[i])&#123;\n        pos.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; pos.size() &amp;&amp; pos[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        isprime[i * pos[j]] &#x3D; 1;\n        if (i % pos[j] &#x3D;&#x3D; 0)&#123;\n            break;\n        &#125;\n    &#125;\n&#125;</code></pre>\n</li>\n<li>\n<p>矩阵快速幂，矩阵加速递推</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct node&#123;\n    int a[n][n];\n    node()&#123;memset(a, 0, sizeof(a))&#125;&#x2F;&#x2F;初始化\n    node operator * (node b)&#123;\n        node x;\n        for (int i &#x3D; 0; i &lt; n; ++i)&#123;\n           for (int j &#x3D; 0; j &lt; n; ++j)&#123;\n               x[i][j] &#x3D; 0;\n               for (int k &#x3D; 0; k &lt; n; ++k)&#123;\n                   x[i][j] &#x3D; (x[i][j] + a[i][k] % MOD * b[k][j] % MOD) % MOD;\n               &#125;\n           &#125;\n        &#125;\n        return x;\n    &#125;\n&#125;;\nnode qpow(node a, long long b, long long mod)&#123;\n    if (b &#x3D;&#x3D; 1)&#123;\n        return a;\n    &#125;\n    node x;\n    b--;\n    while(b)&#123;\n        if (b &amp; 1)&#123;\n            x &#x3D; x * a;\n        &#125;\n        a &#x3D; a * a;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return x;\n&#125;</code></pre>\n</li>\n<li>\n<p>中国剩余定理（CRT，模数互质）</p>\n<pre class=\"line-numbers language-cpp&#123;\" data-language=\"cpp&#123;\"><code class=\"language-cpp&#123;\">vector&lt;ll&gt; mod(k + 1), yu(k + 1);\nll ans &#x3D; 0, M &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n    M *&#x3D; mod[i];\n&#125;\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    ll mi &#x3D; M &#x2F; mod[i], t, y;\n    euclid(mi, mod[i], t, y);\n    t &#x3D; t % mod[i];\n    ans &#x3D; (ans + yu[i] * mi * t) % M;\n&#125;\ncout &lt;&lt; (ans + M) % M &lt;&lt; &#39;\\n&#39;;</code></pre>\n</li>\n<li>\n<p>扩展中国剩余定理（EXCRT，模数不互质）</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;ll&gt; mod(k + 1), yu(k + 1);\nfor (int i &#x3D; 1; i &lt;&#x3D; k; ++i)&#123;\n    cin &gt;&gt; mod[i] &gt;&gt; yu[i];\n&#125;\nll ans &#x3D; yu[1], mi &#x3D; mod[1], t &#x3D; 0, y &#x3D; 0;\nfor (int i &#x3D; 2; i &lt;&#x3D; k; ++i)&#123;\n    ll res &#x3D; ((yu[i] - ans) % mod[i] + mod[i]) % mod[i];\n    ll gcd &#x3D; euclid(mi, mod[i], t, y);\n    if (res % gcd !&#x3D; 0)&#123;cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;return 0;&#125;\n    t &#x3D; qmul(t, res &#x2F; gcd, mod[i]);\n    ans +&#x3D; t * mi;\n    mi &#x3D; mi &#x2F; gcd * mod[i];\n    ans &#x3D; (ans % mi + mi) % mi;\n&#125;\ncout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;</code></pre>\n</li>\n<li>\n<p>欧拉函数：小于等于n，与n互质的数的个数</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;试除求单个n的欧拉函数\nint n;\nint res &#x3D; n;\nfor (int i &#x3D; 2; i * i &lt;&#x3D; n; ++i)&#123;\n    if (n % i &#x3D;&#x3D; 0)&#123;\n        res &#x3D; res &#x2F; i * (i - 1);\n        while (n % i &#x3D;&#x3D; 0) n &#x2F;&#x3D; i;\n    &#125;\n&#125;\nif (n &gt; 1) res &#x3D; res &#x2F; n * (n - 1);\n\n&#x2F;&#x2F;筛法求1～n的欧拉函数值\nbool vis[maxn];\nvector&lt;int&gt; prime;\nint d[maxn];\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        d[i] &#x3D; i - 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; n; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (prime[j] % i &#x3D;&#x3D; 0)&#123;\n            d[m] &#x3D; d[i] * prime[j];\n            break;\n        &#125;\n        else&#123;\n            d[m] &#x3D; d[i] * (prime[j] - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li>\n<p>线性筛求1～n每个数的约数个数,约数和</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool vis[maxn];\nvector&lt;int&gt; p;\nint d[maxn];&#x2F;&#x2F;储存约数个数\nint a[maxn];&#x2F;&#x2F;最小质因子个数\n\nd[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; 1;\n        d[i] &#x3D; 2;\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m &#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[m] * (a[m] + 1);\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1;\n            d[m] &#x3D; d[i] * 2;\n        &#125;\n    &#125;\n&#125;\n\nint d[maxn];&#x2F;&#x2F;约数和\nint a[maxn];&#x2F;&#x2F;最小质因子约数和\na[1] &#x3D; d[1] &#x3D; 1;\nfor (int i &#x3D; 2; i &lt;&#x3D; maxn; ++i)&#123;\n    if (!vis[i])&#123;\n        a[i] &#x3D; d[i] &#x3D; i + 1;\n        prime.push_back(i);\n    &#125;\n    for (int j &#x3D; 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt;&#x3D; maxn; ++j)&#123;\n        int m&#x3D; prime[j] * i;\n        vis[m] &#x3D; 1;\n        if (i % prime[j] &#x3D;&#x3D; 0)&#123;\n            a[m] &#x3D; prime[j] * a[i] + 1;\n            d[m] &#x3D; d[i] &#x2F; a[i] * a[m];\n            break;\n        &#125;\n        else&#123;\n            a[m] &#x3D; 1 + prime[j];\n            d[m] &#x3D; a[m] * d[i];\n        &#125;\n    &#125;\n&#125;</code></pre>\n<ol start=\"9\">\n<li>\n<p>扩展欧几里得算法</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">ll exgcd(ll a, ll b, ll x, ll y)&#123;\n    return !b ? (x &#x3D; 1, y &#x3D; 0, a) : (exgcd(b, a % b, y, x), y -&#x3D; (a &#x2F; b) * x);\n&#125;</code></pre>\n</li>\n<li></li>\n</ol>\n","text":" 给出一个数，输出它的所有素因子 1&lt;x&lt;1091&lt;x&lt;10^91&lt;x&lt;109 解析：由质数分解定理，即任意x&gt;2x &gt; 2x&gt;2可以表示为 x = {p_1}^{k_1}*{p_2}^{k_2}*{p_3}^{k_3}*{p...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"数据结构","uid":"81579b6c641dedc829a2b0058112fc0c","slug":"数据结构","date":"2022-07-27T10:16:02.000Z","updated":"2022-07-28T12:39:54.099Z","comments":true,"path":"api/articles/数据结构.json","keywords":null,"cover":null,"text":" 1.RMQ-st表 离线查询区间最值 template&lt;class T, class Cmp &#x3D; less&lt;T&gt;&gt; &#x2F;&#x2F;定义模版：数据类型和比较方式，默认广义小于 struct RMQ&#123; const int n;&...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-06-22T04:50:06.000Z","updated":"2022-06-26T17:16:45.378Z","comments":true,"path":"api/articles/队列.json","keywords":null,"cover":null,"text":" 栈 出栈排序 给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序 对当前元素入队，如果栈顶元素大于之后的所有元素，出栈 队列 插队 给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}