{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-06-22T04:50:06.000Z","updated":"2022-06-22T05:14:17.020Z","comments":true,"path":"api/articles/队列.json","keywords":null,"cover":null,"content":"<h3 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\"></a> 队列</h3>\n<h4 id=\"插队\"><a class=\"markdownIt-Anchor\" href=\"#插队\"></a> 插队</h4>\n<p>给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进队后出队</p>\n<p>解答：设计一个队列，如果一个人没有插队一定是当他出队时正好在队伍的开头，即前面的所有人都已经出队。出队时，如果正好这个人在队头，出队，否则，标记这个人已经离开队伍，且插队的人数加一，在每次判断队头的人是不是已经出队之前先用while循环删除已经出队的人</p>\n<h3 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h3>\n<p>建立一个队列，队列中元素单调且满足其中的最大值是当前覆盖区间的最大值，最小值是尾元素，换言之，一个元素只有在有更大的元素入队时才会被删除</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int k;&#x2F;&#x2F;滑动窗口维护最大值，k为窗口长度\nvector&lt;int&gt;a(n+1);&#x2F;&#x2F;元素容器\ndeque&lt;pair&lt;int,int&gt;&gt;q;&#x2F;&#x2F;&#123;序号，值&#125;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(!q.empty()&amp;&amp;q.back().second&lt;a[i].second)&#123;\n        q.pop_back();\n    &#125;\n    q.push_back(&#123;i,a[i]&#125;);\n    if(q.front().first&#x3D;&#x3D;k+x-1)&#123;\n        q.pop_front();\n    &#125;\n    if(i&gt;&#x3D;k)&#123;\n        cout&lt;&lt;q.front()&lt;&lt;&#39;\\n&#39;;\n    &#125;\n&#125;</code></pre>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n","text":" 队列 插队 给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进队后出队 解答：设计一个队列，如果一个人没有插队一定是当他出队时正好在队伍的开头，即前面的所有人都已经出队。出队时，如果...","link":"","photos":[],"count_time":{"symbolsCount":785,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\"> 队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E9%98%9F\"><span class=\"toc-text\"> 插队</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\"> 单调队列</span></a></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"特殊的数据结构","uid":"cf16dcad745c39bc496f066c73c8929e","slug":"特殊的数据结构","date":"2022-05-21T14:49:59.000Z","updated":"2022-05-21T14:53:34.100Z","comments":true,"path":"api/articles/特殊的数据结构.json","keywords":null,"cover":null,"text":" 维护序列中最小未出现过的非负整数，支持插入，查询，删除 用一个数组记录每个数出现过的次数，用set维护一个按大小排列的未出现过数 int cot[maxnum]; set&lt;int&gt;st; int m; int op, x; void solve() &#123; f...","link":"","photos":[],"count_time":{"symbolsCount":613,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}