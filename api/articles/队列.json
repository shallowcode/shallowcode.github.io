{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-06-22T04:50:06.000Z","updated":"2022-06-26T17:16:45.378Z","comments":true,"path":"api/articles/队列.json","keywords":null,"cover":null,"content":"<h3 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\"></a> 栈</h3>\n<h4 id=\"出栈排序\"><a class=\"markdownIt-Anchor\" href=\"#出栈排序\"></a> 出栈排序</h4>\n<p>给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序</p>\n<p>对当前元素入队，如果栈顶元素大于之后的所有元素，出栈</p>\n<h3 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\"></a> 队列</h3>\n<h4 id=\"插队\"><a class=\"markdownIt-Anchor\" href=\"#插队\"></a> 插队</h4>\n<p>给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个人一定先进队后出队</p>\n<p>解答：设计一个队列，如果一个人没有插队一定是当他出队时正好在队伍的开头，即前面的所有人都已经出队。出队时，如果正好这个人在队头，出队，否则，标记这个人已经离开队伍，且插队的人数加一，在每次判断队头的人是不是已经出队之前先用while循环删除已经出队的人</p>\n<h4 id=\"前后调\"><a class=\"markdownIt-Anchor\" href=\"#前后调\"></a> 前后调</h4>\n<p>对于一个给定的序列，有两种操作，一个是将某元素移到队头，一个是将某元素移到队尾，问若干次移动后队列长啥样</p>\n<p>对每个元素x而言，设立数组p[x]=i,另设队头，队尾指针l=1，r=n每次移动元素时直接p[x]=l–或p[x]=r++;最后直接用p[x]的大小排序</p>\n<h3 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h3>\n<p>建立一个队列，队列中元素单调且满足其中的最大值是当前覆盖区间的最大值，最小值是尾元素，换言之，一个元素只有在有更大的元素入队时才会被删除</p>\n<h3 id=\"模版\"><a class=\"markdownIt-Anchor\" href=\"#模版\"></a> 模版</h3>\n<ol>\n<li>判断队头元素是否需要出队</li>\n<li>使用队头的最值</li>\n<li>判断队尾元素是否需要出队</li>\n<li>队尾插入新元素的下标</li>\n</ol>\n<h4 id=\"滑动窗口\"><a class=\"markdownIt-Anchor\" href=\"#滑动窗口\"></a> 滑动窗口</h4>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int k;&#x2F;&#x2F;滑动窗口维护最大值，k为窗口长度\nvector&lt;int&gt;a(n+1);&#x2F;&#x2F;元素容器\ndeque&lt;pair&lt;int,int&gt;&gt;q;&#x2F;&#x2F;&#123;序号，值&#125;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(!q.empty()&amp;&amp;q.back().second&lt;a[i].second)&#123;\n        q.pop_back();\n    &#125;\n    q.push_back(&#123;i,a[i]&#125;);\n    if(q.front().first&#x3D;&#x3D;k+x-1)&#123;\n        q.pop_front();\n    &#125;\n    if(i&gt;&#x3D;k)&#123;\n        cout&lt;&lt;q.front()&lt;&lt;&#39;\\n&#39;;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"连续子序列最大和给出一个序列求出子序列长度不超过m的最大子序列和\"><a class=\"markdownIt-Anchor\" href=\"#连续子序列最大和给出一个序列求出子序列长度不超过m的最大子序列和\"></a> 连续子序列最大和:给出一个序列，求出子序列长度不超过m的最大子序列和</h4>\n<p>先用前缀数组预处理给定的序列，将sum[0]=0同样算入，对于 i&gt;=m，考虑<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mi>ϵ</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k \\epsilon [i-m,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathdefault\">ϵ</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>这个区间，通过<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum[i]-sum[k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span>则实现了寻找右边界为i长度不超过m的子序列最大和（只需要找到sum[k]的最小值即可），对于区间移动则可以用单调队列来解决</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int m;&#x2F;&#x2F;序列最大长度\nvector&lt;int&gt;sum(n+1);&#x2F;&#x2F;预处理前缀和数组\ndeque&lt;pair&lt;int,int&gt; &gt;q;\nq.push(&#123;sum[0],0&#125;);\nint ans&#x3D;-0x7fffffff;\nfor (int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;\n    while(q.size()&amp;&amp;q.back().first&gt;sum[i])q.pop_back();\n    if(i&gt;&#x3D;m)&#123;\n        ans&#x3D;max(ans,sum[i]-sum[q.front().second]);\n    &#125;\n    q.push_back(&#123;sum[i],i&#125;);\n    if(q.front().second&#x3D;&#x3D;i-m+1)q.pop_front();\n    cout&lt;&lt;ans&lt;&lt;&#39;\\n&#39;;\n&#125;</code></pre>\n<h3 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h3>\n<p>寻找某一个元素作为最大值或最小值，向左或向右扩展的区间</p>\n<p>ex:</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">stack&lt;pair&lt;int,int&gt; &gt;s;&#x2F;&#x2F;(a[i],i)\nvector&lt;int&gt;r(n+1);&#x2F;&#x2F;作为最大值扩展区间的右边界\nfor(int i&#x3D;n;i&gt;&#x3D;1;--i)&#123;\n    while(!s.empty()&amp;&amp;s.top().first&lt;a[i])s.pop();\n    if(s.empty())r[i]&#x3D;n;\n    else r[i]&#x3D;s.top().second-1;\n    s.push(&#123;a[i],i&#125;);\n&#125;</code></pre>\n<h4 id=\"区区区间间间\"><a class=\"markdownIt-Anchor\" href=\"#区区区间间间\"></a> 区区区间间间</h4>\n<p>定义价值为一个区间最大值-最小值</p>\n<p>求所有长度大于2区间的价值总和</p>\n<p>跑两遍单调栈，对于每个元素，其作为端点管理的区间加上其作为区间内管理的区间，值得注意的是跑两遍中，应有一遍不加等号一遍加，这样在出现相同元素相邻时一个元素只作为端点管理一边，而一个元素会管理另一边，杜绝了区间重复发生</p>\n","text":" 栈 出栈排序 给出一个入栈顺序，是一个1～n的排序，求字典序最大的出栈顺序 对当前元素入队，如果栈顶元素大于之后的所有元素，出栈 队列 插队 给出若干进队出队信息，如果出队则一定是从队头出队，如果入队则分为正常入队和插队入队，题目保证当所有信息给出后所有进队的人都已出队，且一个...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\"> 栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BA%E6%A0%88%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 出栈排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\"> 队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E9%98%9F\"><span class=\"toc-text\"> 插队</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%90%8E%E8%B0%83\"><span class=\"toc-text\"> 前后调</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\"> 单调队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%89%88\"><span class=\"toc-text\"> 模版</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\"> 滑动窗口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%9C%80%E5%A4%A7%E5%92%8C%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B1%82%E5%87%BA%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C\"><span class=\"toc-text\"> 连续子序列最大和:给出一个序列，求出子序列长度不超过m的最大子序列和</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\"> 单调栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%8C%BA%E5%8C%BA%E9%97%B4%E9%97%B4%E9%97%B4\"><span class=\"toc-text\"> 区区区间间间</span></a></li></ol></li></ol>","author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}},"mapped":true,"prev_post":{"title":"math","uid":"d176c206991d53e1e298250d745ffd4f","slug":"math","date":"2022-07-22T13:11:52.000Z","updated":"2022-10-08T09:03:42.060Z","comments":true,"path":"api/articles/math.json","keywords":null,"cover":null,"text":" 质数分解定理：$$x = {p_1}{k_1}*{p_2}{k_2}{p_3}{k_3}*{p_4}{k_4}···{p_n}^{k_n}$$ &#x2F;&#x2F;试除法 int x; for (int i &#x3D; 2; i * i &lt;&#x3D; x; ++i...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}},"next_post":{"title":"特殊的数据结构","uid":"cf16dcad745c39bc496f066c73c8929e","slug":"特殊的数据结构","date":"2022-05-21T14:49:59.000Z","updated":"2022-05-21T14:53:34.100Z","comments":true,"path":"api/articles/特殊的数据结构.json","keywords":null,"cover":null,"text":" 维护序列中最小未出现过的非负整数，支持插入，查询，删除 用一个数组记录每个数出现过的次数，用set维护一个按大小排列的未出现过数 int cot[maxnum]; set&lt;int&gt;st; int m; int op, x; void solve() &#123; f...","link":"","photos":[],"count_time":{"symbolsCount":613,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"shallow","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/e34cf65a5d76470da93ba82bf95b3745.png","link":"/","description":"我并非生来勇敢，天赋过人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/475614133/dynamic"},"github":{"icon":"/svg/github.svg","link":"https://github.com/shallowcode"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/qian-meng-9-42-73"}}}}}}